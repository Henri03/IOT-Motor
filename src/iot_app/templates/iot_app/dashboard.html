{% load static %}
<!DOCTYPE html>
<html lang="de ">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Set the title of the dashboard using motor information -->
    <title>IoT Dashboard: {{ motor_info.name }}</title>
    <style>
        /* Basic styling for the body */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #eef2f7;
            color: #333;
            line-height: 1.6;
        }
        /* Container for the main content, centering it and applying shadow */
        .container {
            max-width: 1200px;
            margin: 20px auto;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        /* Styling for the header section */
        .header-box {
            background-color: #0056b3;
            color: white;
            padding: 25px 30px;
            text-align: center;
            border-bottom: 5px solid #004085;
        }
        /* Header title styling */
        .header-box h1 {
            margin: 0 0 10px 0;
            font-size: 2.5em;
        }
        /* Header paragraph styling */
        .header-box p {
            margin: 0;
            font-size: 1.1em;
            opacity: 0.9;
        }
        /* Layout for displaying motor information in the header */
        .header-info {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 15px;
        }
        /* Styling for individual info items in the header */
        .header-info div {
            background-color: rgba(255,255,255,0.15);
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 0.9em;
            flex-basis: 200px; /* Base width for flex items */
        }
        /* Styling for strong text within header info */
        .header-info strong {
            display: block;
            font-size: 1.2em;
            margin-bottom: 3px;
        }

        /* Styling for navigation links */
        .navigation-links {
            margin-top: 20px;
        }
        /* Styling for navigation buttons */
        .nav-button {
            display: inline-block;
            background-color: #007bff;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            text-decoration: none;
            font-weight: bold;
            transition: background-color 0.3s ease;
            margin: 0 5px;
        }
        /* Hover effect for navigation buttons */
        .nav-button:hover {
            background-color: #0056b3;
        }

        /* Styling for the anomaly status display */
        .anomaly-status {
            padding: 15px 30px;
            border-radius: 0 0 10px 10px;
            font-size: 1.1em;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        /* Specific styling for no anomaly alert */
        .no-anomaly-alert {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        /* Specific styling for anomaly alert */
        .anomaly-alert {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        /* Layout for the main dashboard columns */
        .main-dashboard-columns {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            padding: 30px;
        }
        /* Styling for individual dashboard columns */
        .dashboard-column {
            flex: 1; /* Allows columns to grow and shrink */
            min-width: 45%; /* Minimum width to prevent excessive shrinking */
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        /* Styling for data panels */
        .data-panel {
            background-color: #f9fbfd;
            border: 1px solid #e0e6ed;
            border-radius: 8px;
            padding: 25px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            flex-grow: 0; /* Prevents panel from growing unnecessarily */
        }
        /* Heading styling within data panels */
        .data-panel h2 {
            color: #0056b3;
            margin-top: 0;
            border-bottom: 2px solid #e0e6ed;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        /* Styling for the motor display section */
        .motor-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
        }
        /* Styling for the motor image container */
        .motor-image {
            width: 180px;
            height: 180px;
            background-color: #ccc;
            border-radius: 50%; /* Makes image circular */
            overflow: hidden;
            margin-bottom: 15px;
            border: 3px solid #0056b3;
            box-shadow: 0 0 15px rgba(0,86,179,0.3);
        }
        /* Styling for the actual motor image */
        .motor-image img {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Ensures image covers the area */
        }
        /* Grid layout for displaying data items */
        .data-grid {
            display: grid;
            grid-template-columns: 1fr 1fr; /* Two columns */
            gap: 15px;
            text-align: left;
        }
        /* Styling for individual data items */
        .data-item {
            padding: 8px 0;
            border-bottom: 1px dashed #eee;
        }
        /* Padding for alternating data items */
        .data-item:nth-child(odd) {
            padding-right: 10px;
        }
        .data-item:nth-child(even) {
            padding-left: 10px;
        }
        /* Remove bottom border for last data items */
        .data-item:last-child, .data-grid div:nth-last-child(2) {
            border-bottom: none;
        }
        /* Styling for strong text in data items */
        .data-item strong {
            color: #004085;
        }
        /* Styling for span elements in data items (values) */
        .data-item span {
            float: right;
            font-weight: bold;
        }

        /* Styling for graph sections */
        .graph-section {
            background-color: #f9fbfd;
            border: 1px solid #e0e6ed;
            border-radius: 8px;
            padding: 25px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        /* Heading styling within graph sections */
        .graph-section h2 {
            color: #0056b3;
            border-bottom: 2px solid #e0e6ed;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        /* Container for multiple graphs */
        .graph-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: space-around;
        }
        /* Wrapper for individual charts */
        .chart-wrapper {
            flex: 1;
            min-width: 100%; /* Charts take full width on smaller screens */
            background: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            text-align: center;
            height: 350px; /* Fixed height for charts */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        /* Heading styling within chart wrappers */
        .chart-wrapper h3 {
            color: #0056b3;
            margin-top: 0;
            margin-bottom: 10px;
        }
        /* Styling for canvas elements (charts) */
        .chart-wrapper canvas {
            height: 280px;
            width: 100%;
            flex-grow: 1;
        }

        /* Styling for the time range selector section */
        .time-range-selector {
            background-color: #f9fbfd;
            border: 1px solid #e0e6ed;
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            text-align: center;
        }
        /* Label styling within time range selector */
        .time-range-selector label {
            margin-right: 10px;
            font-weight: bold;
            color: #0056b3;
        }
        /* Input field styling for date/time */
        .time-range-selector input[type="datetime-local"] {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-right: 10px;
            width: 200px;
        }
        /* Dropdown styling for time range selector */
        .time-range-selector select {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-right: 10px;
            width: 150px;
        }
        /* Button styling within time range selector */
        .time-range-selector button {
            background-color: #28a745;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s ease;
            margin: 5px;
        }
        /* Hover effect for time range selector buttons */
        .time-range-selector button:hover {
            background-color: #218838;
        }

        /* Footer styling */
        .footer {
            margin-top: 30px;
            text-align: center;
            color: #777;
            font-size: 0.85em;
            padding: 20px;
            background-color: #eef2f7;
            border-top: 1px solid #e0e6ed;
        }
        /* Link styling in the footer */
        .footer a {
            color: #0056b3;
            text-decoration: none;
        }
        /* Hover effect for footer links */
        .footer a:hover {
            text-decoration: underline;
        }

        /* Responsive design for smaller screens */
        @media (max-width: 768px) {
            /* Stack dashboard columns vertically */
            .main-dashboard-columns {
                flex-direction: column;
                padding: 15px;
            }
            /* Make columns take full width */
            .dashboard-column {
                min-width: 100%;
            }
            /* Stack header info items vertically */
            .header-info {
                flex-direction: column;
                align-items: stretch;
            }
            /* Center text in header info items */
            .header-info div {
                text-align: center;
            }
            /* Make data grid a single column */
            .data-grid {
                grid-template-columns: 1fr;
            }
            /* Remove padding for data items in single column layout */
            .data-item:nth-child(odd), .data-item:nth-child(even) {
                padding-left: 0;
                padding-right: 0;
            }
            /* Make chart wrappers take full width */
            .chart-wrapper {
                min-width: 100%;
            }
            /* Make time range inputs and buttons take full width */
            .time-range-selector input[type="datetime-local"],
            .time-range-selector select {
                width: 100%;
                margin-bottom: 10px;
            }
            .time-range-selector button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header section displaying motor name, model, description, and key information -->
        <div class="header-box">
            <h1>{{ motor_info.name }} {{ motor_info.model }} IoT Dashboard</h1>
            <p>{{ motor_info.description }}</p>
            <div class="header-info">
                <div><strong>Kennzeichnung:</strong> {{ motor_info.identification }}</div>
                <div><strong>Ort:</strong> {{ motor_info.location }}</div>
                <div><strong>Inbetriebnahme:</strong> {{ motor_info.commissioning_date|default:"N/A" }}</div>
                <div><strong>Betriebsmodus:</strong> {{ motor_info.operating_mode }}</div>
            </div>
            <!-- Navigation link to the malfunction log page -->
            <div class="navigation-links">
                <a href="{% url 'iot_app:malfunction_log' %}" class="nav-button">Störmeldungs-Log anzeigen</a>
            </div>
        </div>

        <!-- Anomaly status display, dynamically styled based on 'anomaly_status.detected' -->
        <div id="anomaly-status" class="anomaly-status {% if anomaly_status.detected %}anomaly-alert{% else %}no-anomaly-alert{% endif %}">
            {{ anomaly_status.message }}
        </div>

        <!-- Main dashboard content organized into two columns -->
        <div class="main-dashboard-columns">
            <!-- Left column for real motor data and graphs -->
            <div class="dashboard-column">
                <!-- Panel for current real motor data -->
                <div class="data-panel">
                    <h2>Aktuelle Motordaten</h2>
                    <div class="motor-display">
                        <!-- Image representing the real motor -->
                        <div class="motor-image">
                            <img src="{% static 'images/motor.png' %}" alt="Bild des Elektromotors">
                        </div>
                        <p>Echtzeitdaten vom Frequenzumrichter und angeschlossenen Sensoren.</p>
                    </div>
                    <!-- Grid displaying real-time sensor values -->
                    <div class="data-grid" id="real-motor-data-grid">
                        <div class="data-item"><strong>Strom:</strong> <span id="real-strom">{{ real_motor_data.Current.value|default:'N/A' }} {{ real_motor_data.Current.unit }}</span></div>
                        <div class="data-item"><strong>Spannung:</strong> <span id="real-spannung">{{ real_motor_data.Voltage.value|default:'N/A' }} {{ real_motor_data.Voltage.unit }}</span></div>
                        <div class="data-item"><strong>Drehzahl:</strong> <span id="real-drehzahl">{{ real_motor_data.RPM.value|default:'N/A' }} {{ real_motor_data.RPM.unit }}</span></div>
                        <div class="data-item"><strong>Drehmoment:</strong> <span id="real-drehmoment">{{ real_motor_data.Torque.value|default:'N/A' }} {{ real_motor_data.Torque.unit }}</span></div>
                        <div class="data-item"><strong>Laufzeit:</strong> <span id="real-run-time">{{ real_motor_data.Run_Time.value|default:'N/A' }} {{ real_motor_data.Run_Time.unit }}</span></div>
                    </div>
                </div>

                <!-- Section for real motor data graphs -->
                <div class="graph-section">
                    <h2>Graphen des realen Motors</h2>
                    <div class="graph-container">
                        <!-- Chart for real current -->
                        <div class="chart-wrapper">
                            <h3>Stromverlauf über die Zeit (mit Features)</h3>
                            <canvas id="real-current-chart"></canvas>
                        </div>
                        <!-- Chart for real voltage -->
                        <div class="chart-wrapper">
                            <h3>Spannungsverlauf über die Zeit</h3>
                            <canvas id="real-voltage-chart"></canvas>
                        </div>
                        <!-- Chart for real torque -->
                        <div class="chart-wrapper">
                            <h3>Drehmomentverlauf über die Zeit (mit Features)</h3>
                            <canvas id="real-torque-chart"></canvas>
                        </div>
                        <!-- Chart for real temperature -->
                        <div class="chart-wrapper">
                            <h3>Temperaturverlauf über die Zeit (mit Features)</h3>
                            <canvas id="real-temp-chart"></canvas>
                        </div>
                        <!-- Chart for real RPM -->
                        <div class="chart-wrapper">
                            <h3>Drehzahlverlauf über die Zeit</h3>
                            <canvas id="real-rpm-chart"></canvas>
                        </div>
                        <!-- Chart for real vibration -->
                        <div class="chart-wrapper">
                            <h3>Vibrationsverlauf über die Zeit</h3>
                            <canvas id="real-vibration-chart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right column for digital twin data and graphs -->
            <div class="dashboard-column">
                <!-- Panel for digital twin (expected) data -->
                <div class="data-panel">
                    <h2>Digitaler Zwilling (Erwartete Werte)</h2>
                    <div class="motor-display">
                        <!-- Image representing the digital twin -->
                        <div class="motor-image">
                            <img src="{% static 'images/motor_twin.png' %}" alt="Bild des Digitalen Zwillings">
                        </div>
                        <p>Modellierte Werte basierend auf dem digitalen Zwillingsmodell.</p>
                    </div>
                    <!-- Grid displaying expected sensor values from the digital twin -->
                    <div class="data-grid" id="digital-twin-data-grid">
                        <div class="data-item"><strong>Strom:</strong> <span id="expected-strom">{{ digital_twin_data.Current.value|default:'N/A' }} {{ digital_twin_data.Current.unit }}</span></div>
                        <div class="data-item"><strong>Spannung:</strong> <span id="expected-spannung">{{ digital_twin_data.Voltage.value|default:'N/A' }} {{ digital_twin_data.Voltage.unit }}</span></div>
                        <div class="data-item"><strong>Drehzahl:</strong> <span id="expected-drehzahl">{{ digital_twin_data.RPM.value|default:'N/A' }} {{ digital_twin_data.RPM.unit }}</span></div>
                        <div class="data-item"><strong>Drehmoment:</strong> <span id="expected-drehmoment">{{ digital_twin_data.Torque.value|default:'N/A' }} {{ digital_twin_data.Torque.unit }}</span></div>
                        <div class="data-item"><strong>Laufzeit:</strong> <span id="expected-run-time">{{ digital_twin_data.Run_Time.value|default:'N/A' }} {{ digital_twin_data.Run_Time.unit }}</span></div>
                    </div>
                </div>

                <!-- Section for digital twin data graphs -->
                <div class="graph-section">
                    <h2>Graphen des digitalen Zwillings</h2>
                    <div class="graph-container">
                        <!-- Chart for digital twin current -->
                        <div class="chart-wrapper">
                            <h3>Stromverlauf über die Zeit (Modell)</h3>
                            <canvas id="dt-current-chart"></canvas>
                        </div>
                        <!-- Chart for digital twin voltage -->
                        <div class="chart-wrapper">
                            <h3>Spannungsverlauf über die Zeit (Modell)</h3>
                            <canvas id="dt-voltage-chart"></canvas>
                        </div>
                        <!-- Chart for digital twin torque -->
                        <div class="chart-wrapper">
                            <h3>Drehmomentverlauf über die Zeit (Modell)</h3>
                            <canvas id="dt-torque-chart"></canvas>
                        </div>
                        <!-- Chart for digital twin temperature -->
                        <div class="chart-wrapper">
                            <h3>Temperaturverlauf über die Zeit (Modell)</h3>
                            <canvas id="dt-temp-chart"></canvas>
                        </div>
                        <!-- Chart for digital twin RPM -->
                        <div class="chart-wrapper">
                            <h3>Drehzahlverlauf über die Zeit (Modell)</h3>
                            <canvas id="dt-rpm-chart"></canvas>
                        </div>
                        <!-- Chart for digital twin vibration -->
                        <div class="chart-wrapper">
                            <h3>Vibrationsverlauf über die Zeit (Modell)</h3>
                            <canvas id="dt-vibration-chart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Time range selector for plotting historical data -->
        <div class="time-range-selector">
            <h2>Plot-Zeitbereich auswählen</h2>
            <div>
                <label for="plot-start-time">Startzeit:</label>
                <input type="datetime-local" id="plot-start-time" step="1">
                <label for="plot-end-time">Endzeit:</label>
                <input type="datetime-local" id="plot-end-time" step="1">
                <label for="end-time-mode">Endzeit-Modus:</label>
                <select id="end-time-mode">
                    <option value="fixed">Festgelegt</option>
                    <option value="live">Live</option>
                </select>
                <button id="apply-time-range" class="nav-button">Anwenden</button>
                <button id="reset-time-range" class="nav-button">Aktuellen Lauf anzeigen</button>
            </div>
        </div>

        <!-- Footer section -->
        <div class="footer">
            <p>&copy; {{ current_year }} IoT Dashboard. Alle Rechte vorbehalten.</p>
            <p>Verwaltung: <a href="/admin/" target="_blank">Admin-Panel</a></p>
        </div>
    </div>

   <!-- Chart.js library for creating graphs -->
   <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
   <!-- Chart.js adapter for date-fns for time series data -->
   <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

   <script>
        // Determine WebSocket protocol based on current page's protocol
        const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
        // Construct WebSocket URL for the dashboard endpoint
        const ws_path = protocol + window.location.host + `/ws/dashboard/`;
        // Create a new WebSocket connection
        const socket = new WebSocket(ws_path);

        // Object to store Chart.js instances
        let charts = {};
        // Flag to indicate if a manual time range is active for plotting
        let manualTimeRangeActive = false;
        // Flag to indicate if the end time is set to "live"
        let liveEndTimeMode = false;
        // Maximum number of data points to display in real-time charts
        const MAX_DATA_POINTS = 500;

        // Configuration for shared Y-axis scales across corresponding charts
        const yAxisSharedGroups = {
            'current': {
                realChartId: 'real-current-chart',
                twinChartId: 'dt-current-chart',
                realDatasets: [
                    { datasetIndex: 0 }, // Raw Current
                    { datasetIndex: 1 }, // Mean
                    { datasetIndex: 2 }, // Min
                    { datasetIndex: 3 }, // Max
                    { datasetIndex: 4 }, // Median
                    { datasetIndex: 5 }, // Std
                ],
                twinDatasets: [
                    { datasetIndex: 0 }, // Twin Current
                    { datasetIndex: 1 }, // Twin Mean
                    { datasetIndex: 2 }, // Twin Min
                    { datasetIndex: 3 }, // Twin Max
                    { datasetIndex: 4 }, // Twin Median
                    { datasetIndex: 5 }, // Twin Std
                ],
                yAxisID: 'y'
            },
            'voltage': {
                realChartId: 'real-voltage-chart', realDatasets: [{ datasetIndex: 0 }], // Live Voltage
                twinChartId: 'dt-voltage-chart', twinDatasets: [{ datasetIndex: 0 }], // Twin Voltage
                yAxisID: 'y'
            },
            'torque': {
                realChartId: 'real-torque-chart',
                twinChartId: 'dt-torque-chart',
                realDatasets: [
                    { datasetIndex: 0 }, // Raw Torque
                    { datasetIndex: 1 }, // Mean
                    { datasetIndex: 2 }, // Min
                    { datasetIndex: 3 }, // Max
                    { datasetIndex: 4 }, // Median
                    { datasetIndex: 5 }, // Std
                ],
                twinDatasets: [
                    { datasetIndex: 0 }, // Twin Torque
                    { datasetIndex: 1 }, // Twin Mean
                    { datasetIndex: 2 }, // Twin Min
                    { datasetIndex: 3 }, // Twin Max
                    { datasetIndex: 4 }, // Twin Median
                    { datasetIndex: 5 }, // Twin Std
                ],
                yAxisID: 'y'
            },
            'temp': {
                realChartId: 'real-temp-chart',
                twinChartId: 'dt-temp-chart',
                realDatasets: [
                    { datasetIndex: 0 }, // Raw Temperature
                    { datasetIndex: 1 }, // Mean
                    { datasetIndex: 2 }, // Min
                    { datasetIndex: 3 }, // Max
                    { datasetIndex: 4 }, // Median
                    { datasetIndex: 5 }, // Std
                ],
                twinDatasets: [
                    { datasetIndex: 0 }, // Twin Temperature
                    { datasetIndex: 1 }, // Twin Mean
                    { datasetIndex: 2 }, // Twin Min
                    { datasetIndex: 3 }, // Twin Max
                    { datasetIndex: 4 }, // Twin Median
                    { datasetIndex: 5 }, // Twin Std
                ],
                yAxisID: 'y'
            },
            'rpm': {
                realChartId: 'real-rpm-chart', realDatasets: [{ datasetIndex: 0 }], // Live RPM
                twinChartId: 'dt-rpm-chart', twinDatasets: [{ datasetIndex: 0 }], // Twin RPM
                yAxisID: 'y'
            },
            'vibration': {
                realChartId: 'real-vibration-chart', realDatasets: [{ datasetIndex: 0 }], // Live Vibration
                twinChartId: 'dt-vibration-chart', twinDatasets: [{ datasetIndex: 0 }], // Twin Vibration
                yAxisID: 'y'
            }
        };

        /**
         * Converts a string to a URL-friendly slug format.
         * @param {string} text - The input string.
         * @returns {string} The slugified string.
         */
        function createSlug(text) {
            return text.toLowerCase()
                       .replace(/[\s_]+/g, '-') // Replace spaces/underscores with hyphens
                       .replace(/[^a-z0-9-]+/g, '') // Remove non-alphanumeric characters except hyphens
                       .replace(/^-*|-*$/g, ''); // Trim leading/trailing hyphens
        }

        /**
         * Initializes a Chart.js chart on a given canvas.
         * @param {string} canvasId - The ID of the canvas element.
         * @param {string} title - The title of the chart.
         * @param {Array<Object>} datasetsConfig - An array of dataset configurations.
         * @param {Object} chartOptions - Additional Chart.js options to merge.
         * @returns {Chart} The initialized Chart.js instance.
         */
        function initializeChart(canvasId, title, datasetsConfig, chartOptions = {}) {
            // Get the 2D rendering context of the canvas
            const ctx = document.getElementById(canvasId).getContext('2d');
            // Default options for all charts
            const defaultOptions = {
                responsive: true,
                maintainAspectRatio: false,
                animation: { duration: 0 }, // Disable animation for real-time updates
                plugins: {
                    legend: { display: true },
                    tooltip: { mode: 'index', intersect: false }
                },
                scales: {
                    x: {
                        type: 'time', // X-axis is time-based
                        time: {
                            unit: 'second',
                            displayFormats: { second: 'HH:mm:ss' }
                        },
                        title: { display: true, text: 'Zeit' },
                        min: undefined, // Will be set dynamically
                        max: undefined, // Will be set dynamically
                    }
                }
            };

            // Merge default options with any provided custom options
            const mergedOptions = {
                ...defaultOptions,
                ...chartOptions,
                scales: {
                    ...defaultOptions.scales,
                    ...(chartOptions.scales || {}) // Merge scales specifically
                }
            };

            // Create a new Chart.js instance
            const newChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: datasetsConfig.map(ds => ({
                        label: ds.label,
                        data: [], // Initial empty data array
                        borderColor: ds.borderColor,
                        backgroundColor: ds.backgroundColor || 'rgba(0, 0, 0, 0)', // Transparent background by default
                        borderWidth: ds.borderWidth || 2,
                        pointRadius: ds.pointRadius || 0, // No points displayed by default
                        pointBackgroundColor: ds.pointBackgroundColor || ds.borderColor,
                        pointStyle: ds.pointStyle || 'circle', // Default point style
                        tension: ds.tension || 0.1, // Smooth line tension
                        yAxisID: ds.yAxisID || 'y', // Default Y-axis ID
                        borderDash: ds.borderDash || [],
                        showLine: ds.showLine !== undefined ? ds.showLine : true, // Show line by default
                    }))
                },
                options: mergedOptions
            });
            // Store the chart instance in the global 'charts' object
            charts[canvasId] = newChart;
            return newChart;
        }

        /**
         * Applies shared Y-axis scaling across corresponding charts.
         * This ensures that the Y-axis range is consistent for related metrics.
         */
        function applySharedYAxisScale() {
            for (const metricKey in yAxisSharedGroups) {
                const group = yAxisSharedGroups[metricKey];
                const realChart = charts[group.realChartId];
                const twinChart = charts[group.twinChartId];

                const allYValues = [];

                // Collect data from real chart datasets
                if (realChart && group.realDatasets) {
                    group.realDatasets.forEach(ds => {
                        if (realChart.data.datasets[ds.datasetIndex]) {
                            realChart.data.datasets[ds.datasetIndex].data.forEach(p => allYValues.push(p.y));
                        }
                    });
                }
                // Collect data from twin chart datasets
                if (twinChart && group.twinDatasets) {
                    group.twinDatasets.forEach(ds => {
                        if (twinChart.data.datasets[ds.datasetIndex]) {
                            twinChart.data.datasets[ds.datasetIndex].data.forEach(p => allYValues.push(p.y));
                        }
                    });
                }

                if (allYValues.length > 0) {
                    let minVal = Math.min(...allYValues);
                    let maxVal = Math.max(...allYValues);

                    const padding = (maxVal - minVal) * 0.1;
                    minVal = minVal - padding;
                    maxVal = maxVal + padding;

                    if (minVal < 0 && Math.min(...allYValues) >= 0) minVal = 0;

                    // Apply to real chart
                    if (realChart && realChart.options.scales[group.yAxisID]) {
                        realChart.options.scales[group.yAxisID].min = minVal;
                        realChart.options.scales[group.yAxisID].max = maxVal;
                        realChart.update('none');
                    }
                    // Apply to twin chart
                    if (twinChart && twinChart.options.scales[group.yAxisID]) {
                        twinChart.options.scales[group.yAxisID].min = minVal;
                        twinChart.options.scales[group.yAxisID].max = maxVal;
                        twinChart.update('none');
                    }
                } else {
                    // Reset to auto-scaling if no data
                    if (realChart && realChart.options.scales[group.yAxisID]) {
                        realChart.options.scales[group.yAxisID].min = undefined;
                        realChart.options.scales[group.yAxisID].max = undefined;
                        realChart.update('none');
                    }
                    if (twinChart && twinChart.options.scales[group.yAxisID]) {
                        twinChart.options.scales[group.yAxisID].min = undefined;
                        twinChart.options.scales[group.yAxisID].max = undefined;
                        twinChart.update('none');
                    }
                }
            }
        }

        /**
         * Updates the UI elements (data values and anomaly status) with new data.
         * @param {Object} data - The data object received from the WebSocket.
         */
        function updateUI(data) {
            // Update real motor data
            if (data.real_motor_data) {
                const realData = data.real_motor_data;
                for (const key in realData) {
                    const slugifiedKey = createSlug(key);
                    const elementId = `real-${slugifiedKey}`;
                    const element = document.getElementById(elementId);
                    if (element) {
                        const newValue = realData[key].value !== null ? realData[key].value : 'N/A';
                        element.textContent = `${newValue} ${realData[key].unit}`;
                    }
                }
            }

            // Update digital twin data
            if (data.digital_twin_data) {
                const twinData = data.digital_twin_data;
                for (const key in twinData) {
                    const slugifiedKey = createSlug(key);
                    const elementId = `expected-${slugifiedKey}`;
                    const element = document.getElementById(elementId);
                    if (element) {
                        const newValue = twinData[key].value !== null ? twinData[key].value : 'N/A';
                        element.textContent = `${newValue} ${twinData[key].unit}`;
                    }
                }
            }

            // Update anomaly status
            if (data.anomaly_status) {
                const anomalyStatusElement = document.getElementById('anomaly-status');
                const anomaly = data.anomaly_status;
                if (anomalyStatusElement) {
                    anomalyStatusElement.textContent = anomaly.message;
                    // Apply appropriate CSS class based on anomaly detection
                    if (anomaly.detected) {
                        anomalyStatusElement.className = 'anomaly-status anomaly-alert';
                    } else {
                        anomalyStatusElement.className = 'anomaly-status no-anomaly-alert';
                    }
                }
            }
        }

        /**
         * Returns the background color for a data point based on its prediction status.
         * @param {number} prediction - The prediction status (-1 for bad, 1 for good, 0 or null for neutral).
         * @returns {string} The color string.
         */
        const getPointBackgroundColor = (prediction) => {
            if (prediction === 1) return 'green'; // Good value
            if (prediction === -1) return 'red'; // Bad value
            return 'blue'; // Default color if no prediction or 0
        };

        /**
         * Returns the point style for a data point based on its prediction status.
         * @param {number} prediction - The prediction status (-1 for bad, 1 for good, 0 or null for neutral).
         * @returns {string} The point style string ('circle', 'cross', etc.).
         */
        const getPointStyle = (prediction) => {
            if (prediction === -1) return 'cross'; // Bad value as a cross
            return 'circle'; // Good or neutral value as a circle
        };

        /**
         * Updates all charts with historical data received from the server.
         * Clears existing chart data and repopulates with the new historical data.
         * @param {Object} plotData - Historical data for live, twin, raw, and feature metrics.
         * @param {string} plotType - Type of plot data (e.g., 'initial_historical', 'historical_range').
         * @param {string} startTime - The start time of the historical data range.
         * @param {string} endTime - The end time of the historical data range.
         */
        function updateChartsWithHistoricalData(plotData, plotType, startTime, endTime) {
            // Clear all existing chart data
            Object.values(charts).forEach(chart => {
                chart.data.datasets.forEach(dataset => {
                    dataset.data = [];
                });
            });

            // Populate real motor charts with historical data
            // Prioritize raw data for current, temperature, torque
            if (plotData.raw) {
                if (plotData.raw.current) {
                    const dataset = charts['real-current-chart'].data.datasets[0];
                    dataset.data = plotData.raw.current.map(p => ({
                        x: new Date(p.x),
                        y: p.y,
                        pointBackgroundColor: getPointBackgroundColor(p.prediction),
                        pointStyle: getPointStyle(p.prediction)
                    }));
                }
                if (plotData.raw.temperature) {
                    const dataset = charts['real-temp-chart'].data.datasets[0];
                    dataset.data = plotData.raw.temperature.map(p => ({
                        x: new Date(p.x),
                        y: p.y,
                        pointBackgroundColor: getPointBackgroundColor(p.prediction),
                        pointStyle: getPointStyle(p.prediction)
                    }));
                }
                if (plotData.raw.torque) {
                    const dataset = charts['real-torque-chart'].data.datasets[0];
                    dataset.data = plotData.raw.torque.map(p => ({
                        x: new Date(p.x),
                        y: p.y,
                        pointBackgroundColor: getPointBackgroundColor(p.prediction),
                        pointStyle: getPointStyle(p.prediction)
                    }));
                }
            }
            // Use live data for voltage, rpm, vibration, and as fallback for current/temp/torque if raw is missing
            if (plotData.live) {
                if (plotData.live.voltage) charts['real-voltage-chart'].data.datasets[0].data = plotData.live.voltage.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.live.rpm) charts['real-rpm-chart'].data.datasets[0].data = plotData.live.rpm.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.live.vibration) charts['real-vibration-chart'].data.datasets[0].data = plotData.live.vibration.map(p => ({x: new Date(p.x), y: p.y}));
                
                // Fallback for current, temp, torque if raw data was not available or empty
                // Note: Fallback live data points will have default blue circle style as they don't have prediction
                if (!plotData.raw || !plotData.raw.current || plotData.raw.current.length === 0) {
                    if (plotData.live.current) {
                        const dataset = charts['real-current-chart'].data.datasets[0];
                        dataset.data = plotData.live.current.map(p => ({x: new Date(p.x), y: p.y}));
                    }
                }
                if (!plotData.raw || !plotData.raw.temperature || plotData.raw.temperature.length === 0) {
                    if (plotData.live.temp) {
                        const dataset = charts['real-temp-chart'].data.datasets[0];
                        dataset.data = plotData.live.temp.map(p => ({x: new Date(p.x), y: p.y}));
                    }
                }
                if (!plotData.raw || !plotData.raw.torque || plotData.raw.torque.length === 0) {
                    if (plotData.live.torque) {
                        const dataset = charts['real-torque-chart'].data.datasets[0];
                        dataset.data = plotData.live.torque.map(p => ({x: new Date(p.x), y: p.y}));
                    }
                }
            }

            // Populate digital twin charts with historical data
            if (plotData.twin) {
                if (plotData.twin.current) charts['dt-current-chart'].data.datasets[0].data = plotData.twin.current.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.twin.voltage) charts['dt-voltage-chart'].data.datasets[0].data = plotData.twin.voltage.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.twin.rpm) charts['dt-rpm-chart'].data.datasets[0].data = plotData.twin.rpm.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.twin.vibration) charts['dt-vibration-chart'].data.datasets[0].data = plotData.twin.vibration.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.twin.temp) charts['dt-temp-chart'].data.datasets[0].data = plotData.twin.temp.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.twin.torque) charts['dt-torque-chart'].data.datasets[0].data = plotData.twin.torque.map(p => ({x: new Date(p.x), y: p.y}));
            }

            // Populate feature data into the respective real data charts
            if (plotData.feature) {
                // Temperature Features (Real)
                if (plotData.feature.temperature_mean) charts['real-temp-chart'].data.datasets[1].data = plotData.feature.temperature_mean.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.temperature_min) charts['real-temp-chart'].data.datasets[2].data = plotData.feature.temperature_min.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.temperature_max) charts['real-temp-chart'].data.datasets[3].data = plotData.feature.temperature_max.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.temperature_median) charts['real-temp-chart'].data.datasets[4].data = plotData.feature.temperature_median.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.temperature_std) charts['real-temp-chart'].data.datasets[5].data = plotData.feature.temperature_std.map(p => ({x: new Date(p.x), y: p.y}));

                // Current Features (Real)
                if (plotData.feature.current_mean) charts['real-current-chart'].data.datasets[1].data = plotData.feature.current_mean.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.current_min) charts['real-current-chart'].data.datasets[2].data = plotData.feature.current_min.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.current_max) charts['real-current-chart'].data.datasets[3].data = plotData.feature.current_max.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.current_median) charts['real-current-chart'].data.datasets[4].data = plotData.feature.current_median.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.current_std) charts['real-current-chart'].data.datasets[5].data = plotData.feature.current_std.map(p => ({x: new Date(p.x), y: p.y}));

                // Torque Features (Real)
                if (plotData.feature.torque_mean) charts['real-torque-chart'].data.datasets[1].data = plotData.feature.torque_mean.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.torque_min) charts['real-torque-chart'].data.datasets[2].data = plotData.feature.torque_min.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.torque_max) charts['real-torque-chart'].data.datasets[3].data = plotData.feature.torque_max.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.torque_median) charts['real-torque-chart'].data.datasets[4].data = plotData.feature.torque_median.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.torque_std) charts['real-torque-chart'].data.datasets[5].data = plotData.feature.torque_std.map(p => ({x: new Date(p.x), y: p.y}));

                // Temperature Features (Twin)
                if (plotData.feature.temperature_mean) charts['dt-temp-chart'].data.datasets[1].data = plotData.feature.temperature_mean.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.temperature_min) charts['dt-temp-chart'].data.datasets[2].data = plotData.feature.temperature_min.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.temperature_max) charts['dt-temp-chart'].data.datasets[3].data = plotData.feature.temperature_max.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.temperature_median) charts['dt-temp-chart'].data.datasets[4].data = plotData.feature.temperature_median.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.temperature_std) charts['dt-temp-chart'].data.datasets[5].data = plotData.feature.temperature_std.map(p => ({x: new Date(p.x), y: p.y}));

                // Current Features (Twin)
                if (plotData.feature.current_mean) charts['dt-current-chart'].data.datasets[1].data = plotData.feature.current_mean.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.current_min) charts['dt-current-chart'].data.datasets[2].data = plotData.feature.current_min.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.current_max) charts['dt-current-chart'].data.datasets[3].data = plotData.feature.current_max.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.current_median) charts['dt-current-chart'].data.datasets[4].data = plotData.feature.current_median.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.current_std) charts['dt-current-chart'].data.datasets[5].data = plotData.feature.current_std.map(p => ({x: new Date(p.x), y: p.y}));

                // Torque Features (Twin)
                if (plotData.feature.torque_mean) charts['dt-torque-chart'].data.datasets[1].data = plotData.feature.torque_mean.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.torque_min) charts['dt-torque-chart'].data.datasets[2].data = plotData.feature.torque_min.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.torque_max) charts['dt-torque-chart'].data.datasets[3].data = plotData.feature.torque_max.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.torque_median) charts['dt-torque-chart'].data.datasets[4].data = plotData.feature.torque_median.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.torque_std) charts['dt-torque-chart'].data.datasets[5].data = plotData.feature.torque_std.map(p => ({x: new Date(p.x), y: p.y}));
            }

            // Update chart X-axis scales based on the historical time range
            Object.values(charts).forEach(chart => {
                if (startTime && endTime) {
                    chart.options.scales.x.min = new Date(startTime);
                    chart.options.scales.x.max = new Date(endTime);
                } else {
                    // Reset to auto-scaling if no specific time range is provided
                    chart.options.scales.x.min = undefined;
                    chart.options.scales.x.max = undefined;
                }
                chart.update('none'); // Update charts without animation
            });

            // Apply shared Y-axis scaling after updating data
            applySharedYAxisScale();

            // Update time range input fields and manualTimeRangeActive flag
            if (plotType === 'initial_historical') {
                document.getElementById('plot-start-time').value = startTime ? new Date(startTime).toISOString().slice(0, 19) : '';
                document.getElementById('plot-end-time').value = endTime ? new Date(endTime).toISOString().slice(0, 19) : '';
                document.getElementById('end-time-mode').value = 'fixed'; // Set to fixed when initial historical data is loaded
                liveEndTimeMode = false;
                manualTimeRangeActive = false; // Reset to live mode
            } else if (plotType === 'historical_range') {
                manualTimeRangeActive = true; // Stay in manual time range mode
                liveEndTimeMode = (document.getElementById('end-time-mode').value === 'live');
            }
        }

        /**
         * Adds a single new data point to the end of all relevant real-time charts.
         * This function is skipped if a manual time range is active and not in live end time mode.
         * @param {Object} dataPoint - The latest data point containing live and twin metric values.
         */
        function addLatestDataPoint(dataPoint) {
            // Do not update charts with new live data if a manual time range is active AND not in live end time mode
            if (manualTimeRangeActive && !liveEndTimeMode) {
                return;
            }

            // Iterate through all initialized charts
            Object.values(charts).forEach(chart => {
                // Iterate through each dataset within the current chart
                chart.data.datasets.forEach((dataset, datasetIndex) => {
                    let metricKey;
                    let sourceData;
                    let value;
                    let timestamp;
                    let predictionStatus; // New: for raw data point color

                    // Determine the base metric key (e.g., 'current', 'temperature', 'torque')
                    // This logic needs to be robust for both real and twin charts
                    let isTwinChart = chart.canvas.id.startsWith('dt-');
                    let isRawDataset = dataset.label.includes('(Raw)');
                    let isTwinRawDataset = dataset.label.includes('(Nm) ') || dataset.label.includes('(A) ') || dataset.label.includes('(°C) ') || dataset.label.includes('(V) '); // For twin raw data
                    let isFeatureDataset = dataset.label.includes('Mean') || dataset.label.includes('Min') || dataset.label.includes('Max') || dataset.label.includes('Median') || dataset.label.includes('Std');

                    if (dataset.label.includes('Strom')) {
                        metricKey = 'current';
                    } else if (dataset.label.includes('Spannung')) {
                        metricKey = 'voltage';
                    } else if (dataset.label.includes('Drehmoment')) {
                        metricKey = 'torque';
                    } else if (dataset.label.includes('Temperatur')) {
                        metricKey = 'temperature';
                    } else if (dataset.label.includes('Drehzahl')) {
                        metricKey = 'rpm';
                    } else if (dataset.label.includes('Vibration')) {
                        metricKey = 'vibration';
                    } else {
                        // If it's a feature dataset, extract the base metric
                        if (isFeatureDataset) {
                            metricKey = dataset.label.split(' ')[0].toLowerCase().replace('drehmoment', 'torque').replace('strom', 'current').replace('temperatur', 'temperature');
                        } else {
                            return; // Skip if metric key cannot be determined
                        }
                    }

                    if (isFeatureDataset) {
                        const featureType = dataset.label.split(' ')[1].toLowerCase(); // e.g., 'mean'
                        const featureKey = metricKey + '_' + featureType;
                        sourceData = dataPoint.feature[featureKey];
                        if (sourceData) {
                            value = sourceData.y;
                            timestamp = new Date(sourceData.x);
                        }
                    } else if (isTwinChart) { // Digital Twin data
                        if (isTwinRawDataset) { // Twin raw data
                            sourceData = dataPoint.twin;
                            if (sourceData && sourceData[metricKey]) {
                                value = sourceData[metricKey].y;
                                timestamp = new Date(sourceData[metricKey].x);
                            }
                        }
                        // For twin charts, if it's not raw twin data, it must be a feature dataset
                        // This case is handled by the `isFeatureDataset` block above
                    } else { // Real motor data (Raw or Live)
                        if (isRawDataset) { // Real raw data
                            sourceData = dataPoint.raw;
                            if (sourceData && sourceData[metricKey]) {
                                value = sourceData[metricKey].y;
                                timestamp = new Date(sourceData[metricKey].x);
                                predictionStatus = dataPoint.raw[metricKey].prediction;
                            } else { // Fallback to live if raw is not available
                                sourceData = dataPoint.live;
                                if (sourceData && sourceData[metricKey]) {
                                    value = sourceData[metricKey].y;
                                    timestamp = new Date(sourceData[metricKey].x);
                                }
                            }
                        } else { // Live data (Voltage, RPM, Vibration)
                            sourceData = dataPoint.live;
                            if (sourceData && sourceData[metricKey]) {
                                value = sourceData[metricKey].y;
                                timestamp = new Date(sourceData[metricKey].x);
                            }
                        }
                    }
                    
                    if (value !== undefined && timestamp) {
                        const newPoint = { x: timestamp, y: value };
                        if (predictionStatus !== undefined) {
                            newPoint.pointBackgroundColor = getPointBackgroundColor(predictionStatus);
                            newPoint.pointStyle = getPointStyle(predictionStatus);
                            newPoint.pointRadius = 2; // Make points visible for raw data with prediction
                        }
                        dataset.data.push(newPoint);
                    }

                    // Remove oldest data points if MAX_DATA_POINTS limit is exceeded
                    if (dataset.data.length > MAX_DATA_POINTS) {
                        dataset.data.splice(0, dataset.data.length - MAX_DATA_POINTS);
                    }
                });

                // Adjust X-axis min/max to show the latest MAX_DATA_POINTS
                // This logic should only apply if not in a manual time range and not in live end time mode
                if (!manualTimeRangeActive || liveEndTimeMode) {
                    if (chart.data.datasets[0] && chart.data.datasets[0].data.length > 0) {
                        const firstTimestamp = chart.data.datasets[0].data[0].x;
                        const lastTimestamp = chart.data.datasets[0].data[chart.data.datasets[0].data.length - 1].x;
                        
                        if (liveEndTimeMode) {
                            // If live end time mode is active, set max to current time and adjust min to maintain window
                            chart.options.scales.x.max = new Date(); // Current time
                            // Calculate min to maintain the window size based on MAX_DATA_POINTS and data frequency
                            // This is a simplification; a more robust solution might involve average time difference
                            if (chart.data.datasets[0].data.length > 1) { // Use chart.data.datasets[0].data.length
                                const timeDiff = lastTimestamp.getTime() - firstTimestamp.getTime();
                                chart.options.scales.x.min = new Date(chart.options.scales.x.max.getTime() - timeDiff);
                            } else {
                                chart.options.scales.x.min = firstTimestamp;
                            }
                        } else { // Not in manual range, not live end time -> auto-scaling for live data
                            chart.options.scales.x.min = firstTimestamp;
                            chart.options.scales.x.max = lastTimestamp;
                        }
                    } else {
                        // Reset X-axis to auto if no data
                        chart.options.scales.x.min = undefined;
                        chart.options.scales.x.max = undefined;
                    }
                }

                chart.update('none'); // Update chart without animation
            });
            applySharedYAxisScale(); // Re-apply shared Y-axis scaling
        }

        // Event listener for when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize real motor current chart
            initializeChart('real-current-chart', 'Stromverlauf über die Zeit (mit Features)', [
                { label: 'Strom (Raw)', borderColor: 'rgb(0, 150, 136)', pointRadius: 2, showLine: false }, // Teal
                { label: 'Strom Mean', borderColor: 'rgb(255, 159, 64)', borderWidth: 2, tension: 0.3 }, // Orange
                { label: 'Strom Min', borderColor: 'rgb(75, 192, 192)', borderWidth: 1, borderDash: [2, 2] }, // Light Teal
                { label: 'Strom Max', borderColor: 'rgb(255, 99, 132)', borderWidth: 1, borderDash: [2, 2] }, // Red
                { label: 'Strom Median', borderColor: 'rgb(54, 162, 235)', borderWidth: 1, borderDash: [5, 5] }, // Blue
                { label: 'Strom Std', borderColor: 'rgb(153, 102, 255)', borderWidth: 1, borderDash: [1, 1] } // Purple
            ], {
                scales: {
                    y: {
                        title: { display: true, text: 'Strom (A)' },
                        beginAtZero: false
                    }
                }
            });

            // Initialize real motor voltage chart
            initializeChart('real-voltage-chart', 'Spannungsverlauf über die Zeit', [
                { label: 'Spannung (V)', borderColor: 'rgb(255, 99, 132)' }
            ], {
                scales: {
                    y: {
                        title: { display: true, text: 'Spannung (V)' },
                        beginAtZero: false
                    }
                }
            });

            // Initialize real motor RPM chart
            initializeChart('real-rpm-chart', 'Drehzahlverlauf über die Zeit', [
                { label: 'Drehzahl (U/min)', borderColor: 'rgb(54, 162, 235)' }
            ], {
                scales: {
                    y: {
                        title: { display: true, text: 'Drehzahl (U/min)' },
                        beginAtZero: false
                    }
                }
            });
            // Initialize real motor vibration chart
            initializeChart('real-vibration-chart', 'Vibrationsverlauf über die Zeit', [
                { label: 'Vibration (mm/s)', borderColor: 'rgb(255, 205, 86)' }
            ], {
                scales: {
                    y: {
                        title: { display: true, text: 'Vibration (mm/s)' },
                        beginAtZero: false
                    }
                }
            });
            // Initialize real motor temperature chart
            initializeChart('real-temp-chart', 'Temperaturverlauf über die Zeit (mit Features)', [
                { label: 'Temperatur (Raw)', borderColor: 'rgb(153, 102, 255)', pointRadius: 2, showLine: false }, // Raw data as points
                { label: 'Temperatur Mean', borderColor: 'rgba(153, 102, 255, 0.7)', borderWidth: 2, tension: 0.3 },
                { label: 'Temperatur Min', borderColor: 'rgba(0, 123, 255, 0.7)', borderWidth: 1, borderDash: [2, 2] },
                { label: 'Temperatur Max', borderColor: 'rgba(255, 0, 0, 0.7)', borderWidth: 1, borderDash: [2, 2] },
                { label: 'Temperatur Median', borderColor: 'rgba(255, 165, 0, 0.7)', borderWidth: 1, borderDash: [5, 5] },
                { label: 'Temperatur Std', borderColor: 'rgba(128, 128, 128, 0.7)', borderWidth: 1, borderDash: [1, 1] }
            ], {
                scales: {
                    y: {
                        title: { display: true, text: 'Temperatur (°C)' },
                        beginAtZero: false
                    }
                }
            });
            // Initialize real motor torque chart
            initializeChart('real-torque-chart', 'Drehmomentverlauf über die Zeit (mit Features)', [
                { label: 'Drehmoment (Raw)', borderColor: 'rgb(255, 159, 64)', pointRadius: 2, showLine: false }, // Raw data as points
                { label: 'Drehmoment Mean', borderColor: 'rgba(255, 159, 64, 0.7)', borderWidth: 2, tension: 0.3 },
                { label: 'Drehmoment Min', borderColor: 'rgba(0, 123, 255, 0.7)', borderWidth: 1, borderDash: [2, 2] },
                { label: 'Drehmoment Max', borderColor: 'rgba(255, 0, 0, 0.7)', borderWidth: 1, borderDash: [2, 2] },
                { label: 'Drehmoment Median', borderColor: 'rgba(255, 165, 0, 0.7)', borderWidth: 1, borderDash: [5, 5] },
                { label: 'Drehmoment Std', borderColor: 'rgba(128, 128, 128, 0.7)', borderWidth: 1, borderDash: [1, 1] }
            ], {
                scales: {
                    y: {
                        title: { display: true, text: 'Drehmoment (Nm)' },
                        beginAtZero: false
                    }
                }
            });

            // Initialize digital twin current chart with dashed lines
            initializeChart('dt-current-chart', 'Stromverlauf über die Zeit (Modell)', [
                { label: 'Strom (A) ', borderColor: 'rgb(0, 150, 136)' }, // Teal, no dash for twin if real has no dash
                { label: 'Strom Mean ', borderColor: 'rgb(255, 159, 64)', borderWidth: 2, tension: 0.3 }, // Orange
                { label: 'Strom Min ', borderColor: 'rgb(75, 192, 192)', borderWidth: 1, borderDash: [2, 2] }, // Light Teal
                { label: 'Strom Max ', borderColor: 'rgb(255, 99, 132)', borderWidth: 1, borderDash: [2, 2] }, // Red
                { label: 'Strom Median ', borderColor: 'rgb(54, 162, 235)', borderWidth: 1, borderDash: [5, 5] }, // Blue
                { label: 'Strom Std ', borderColor: 'rgb(153, 102, 255)', borderWidth: 1, borderDash: [1, 1] } // Purple
            ], {
                scales: {
                    y: {
                        title: { display: true, text: 'Strom (A)' },
                        beginAtZero: false
                    }
                }
            });

            // Initialize digital twin voltage chart with dashed lines
            initializeChart('dt-voltage-chart', 'Spannungsverlauf über die Zeit (Modell)', [
                { label: 'Spannung (V) ', borderColor: 'rgb(255, 99, 132)' } // No dash for twin if real has no dash
            ], {
                scales: {
                    y: {
                        title: { display: true, text: 'Spannung (V)' },
                        beginAtZero: false
                    }
                }
            });

            // Initialize digital twin RPM chart with dashed lines
            initializeChart('dt-rpm-chart', 'Drehzahlverlauf über die Zeit (Modell)', [
                { label: 'Drehzahl (U/min) ', borderColor: 'rgb(54, 162, 235)' } // No dash for twin if real has no dash
            ], {
                scales: {
                    y: {
                        title: { display: true, text: 'Drehzahl (U/min)' },
                        beginAtZero: false
                    }
                }
            });
            // Initialize digital twin vibration chart with dashed lines
            initializeChart('dt-vibration-chart', 'Vibrationsverlauf über die Zeit (Modell)', [
                { label: 'Vibration (mm/s) ', borderColor: 'rgb(255, 205, 86)' } // No dash for twin if real has no dash
            ], {
                scales: {
                    y: {
                        title: { display: true, text: 'Vibration (mm/s)' },
                        beginAtZero: false
                    }
                }
            });
            // Initialize digital twin temperature chart with dashed lines
            initializeChart('dt-temp-chart', 'Temperaturverlauf über die Zeit (Modell)', [
                { label: 'Temperatur (°C) ', borderColor: 'rgb(153, 102, 255)' }, // No dash for twin if real has no dash
                { label: 'Temperatur Mean ', borderColor: 'rgba(153, 102, 255, 0.7)', borderWidth: 2, tension: 0.3 },
                { label: 'Temperatur Min ', borderColor: 'rgba(0, 123, 255, 0.7)', borderWidth: 1, borderDash: [2, 2] },
                { label: 'Temperatur Max ', borderColor: 'rgba(255, 0, 0, 0.7)', borderWidth: 1, borderDash: [2, 2] },
                { label: 'Temperatur Median ', borderColor: 'rgba(255, 165, 0, 0.7)', borderWidth: 1, borderDash: [5, 5] },
                { label: 'Temperatur Std ', borderColor: 'rgba(128, 128, 128, 0.7)', borderWidth: 1, borderDash: [1, 1] }
            ], {
                scales: {
                    y: {
                        title: { display: true, text: 'Temperatur (°C)' },
                        beginAtZero: false
                    }
                }
            });
            // Initialize digital twin torque chart with dashed lines
            initializeChart('dt-torque-chart', 'Drehmomentverlauf über die Zeit (Modell)', [
                { label: 'Drehmoment (Nm) ', borderColor: 'rgb(255, 159, 64)' }, // No dash for twin if real has no dash
                { label: 'Drehmoment Mean ', borderColor: 'rgba(255, 159, 64, 0.7)', borderWidth: 2, tension: 0.3 },
                { label: 'Drehmoment Min ', borderColor: 'rgba(0, 123, 255, 0.7)', borderWidth: 1, borderDash: [2, 2] },
                { label: 'Drehmoment Max ', borderColor: 'rgba(255, 0, 0, 0.7)', borderWidth: 1, borderDash: [2, 2] },
                { label: 'Drehmoment Median ', borderColor: 'rgba(255, 165, 0, 0.7)', borderWidth: 1, borderDash: [5, 5] },
                { label: 'Drehmoment Std ', borderColor: 'rgba(128, 128, 128, 0.7)', borderWidth: 1, borderDash: [1, 1] }
            ], {
                scales: {
                    y: {
                        title: { display: true, text: 'Drehmoment (Nm)' },
                        beginAtZero: false
                    }
                }
            });
        });

        // WebSocket onopen event handler
        socket.onopen = function(e) {
            console.log("WebSocket connection established.");
            socket.send(JSON.stringify({
                type: 'request_initial_data'
            }));
        };

        // WebSocket onmessage event handler
        socket.onmessage = function(e) {
            try {
                const data = JSON.parse(e.data); // Parse incoming JSON data

                // Handle different types of WebSocket messages
                if (data.error) {
                    console.error("[ERROR] Received error from WebSocket:", data.error);
                    document.getElementById('anomaly-status').textContent = `Fehler: ${data.error}`;
                    document.getElementById('anomaly-status').className = 'anomaly-status anomaly-alert';
                } else if (data.type === 'dashboard_update') {
                    // Update static UI elements with latest dashboard data
                    updateUI(data.message);
                } else if (data.type === 'plot_data_update') {
                    // Update charts with historical data
                    updateChartsWithHistoricalData(data.data, data.plot_type, data.start_time, data.end_time);
                    // Adjust manualTimeRangeActive and liveEndTimeMode flags based on plot_type
                    if (data.plot_type === 'initial_historical') {
                        document.getElementById('plot-start-time').value = data.start_time ? new Date(data.start_time).toISOString().slice(0, 19) : '';
                        document.getElementById('plot-end-time').value = data.end_time ? new Date(data.end_time).toISOString().slice(0, 19) : '';
                        document.getElementById('end-time-mode').value = 'fixed'; // Reset to fixed for initial load
                        liveEndTimeMode = false;
                        manualTimeRangeActive = false; // Back to live mode
                    } else if (data.plot_type === 'historical_range') {
                        manualTimeRangeActive = true; // Stay in manual range mode
                        liveEndTimeMode = (document.getElementById('end-time-mode').value === 'live');
                    }
                } else if (data.type === 'plot_data_point') {
                    // Add new live data point if not in manual time range mode OR if in live end time mode
                    if (!manualTimeRangeActive || liveEndTimeMode) {
                        addLatestDataPoint(data.data);
                    }
                } else {
                    console.warn("[WARN] Unhandled WebSocket message type:", data.type);
                }
            } catch (error) {
                console.error("[CRITICAL ERROR] Error parsing WebSocket message or during UI update:", error, e.data);
            }
        };

        // WebSocket onclose event handler
        socket.onclose = function(e) {
            console.error("WebSocket closed unexpectedly:", e);
            document.getElementById('anomaly-status').textContent = "WebSocket-Verbindung getrennt. Versuche verbindung...";
            document.getElementById('anomaly-status').className = 'anomaly-status anomaly-alert';
            // Attempt to reload the page after a delay to re-establish connection
            setTimeout(() => {
                window.location.reload();
            }, 3000);
        };

        // WebSocket onerror event handler
        socket.onerror = function(e) {
            console.error("WebSocket error:", e);
            document.getElementById('anomaly-status').textContent = "WebSocket-Fehler aufgetreten.";
            document.getElementById('anomaly-status').className = 'anomaly-status anomaly-alert';
        };

        // Event listener for the "Apply" button in the time range selector
        document.getElementById('apply-time-range').addEventListener('click', () => {
            const startTimeInput = document.getElementById('plot-start-time').value;
            const endTimeInput = document.getElementById('plot-end-time').value;
            const endTimeMode = document.getElementById('end-time-mode').value;

            // Validate input
            if (!startTimeInput && endTimeMode === 'fixed' && !endTimeInput) {
                alert('Bitte geben Sie mindestens eine Start- oder Endzeit ein, oder wählen Sie "Live" für die Endzeit.');
                return;
            }

            // Determine the actual end time to send to the backend
            let actualEndTime = endTimeInput;
            if (endTimeMode === 'live') {
                actualEndTime = 'live'; // Send 'live' keyword to backend
            }

            // Send a request to the WebSocket to fetch historical data for the specified range
            socket.send(JSON.stringify({
                type: 'request_plot_data',
                start_time: startTimeInput,
                end_time: actualEndTime // Use 'live' or the fixed date
            }));
            manualTimeRangeActive = true; // Set flag to indicate manual time range is active
            liveEndTimeMode = (endTimeMode === 'live'); // Update liveEndTimeMode flag
        });

        // Event listener for the "Show Current Run" button
        document.getElementById('reset-time-range').addEventListener('click', () => {
            // Clear the time range input fields
            document.getElementById('plot-start-time').value = '';
            document.getElementById('plot-end-time').value = '';
            document.getElementById('end-time-mode').value = 'fixed'; // Reset to fixed
            // Send a request to the WebSocket to revert to displaying initial/live data
            socket.send(JSON.stringify({
                type: 'request_initial_data'
            }));
            manualTimeRangeActive = false; // Reset flag to indicate live mode
            liveEndTimeMode = false; // Reset live end time mode
        });

        // Event listener for the end-time-mode dropdown
        document.getElementById('end-time-mode').addEventListener('change', function() {
            const endTimeInput = document.getElementById('plot-end-time');
            if (this.value === 'live') {
                endTimeInput.disabled = true; // Disable fixed end time input
                endTimeInput.value = ''; // Clear any existing fixed end time
            } else {
                endTimeInput.disabled = false; // Enable fixed end time input
            }
        });
    </script>
</body>
</html>