<!--path: src/iot_app/templates/iot_app/dashboard.html-->

<!--Frontend-->

{% load static %}
<!DOCTYPE html>
<html lang="de ">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Set the title of the dashboard using motor information -->
    <title>IoT Dashboard: {{ motor_info.name }}</title>
    <style>
        /* Basic styling for the body */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #eef2f7;
            color: #333;
            line-height: 1.6;
        }
        /* Container for the main content, centering it and applying shadow */
        .container {
            max-width: 1200px;
            margin: 20px auto;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        /* Styling for the header section */
        .header-box {
            background-color: #0056b3;
            color: white;
            padding: 25px 30px;
            text-align: center;
            border-bottom: 5px solid #004085;
        }
        /* Header title styling */
        .header-box h1 {
            margin: 0 0 10px 0;
            font-size: 2.5em;
        }
        /* Header paragraph styling */
        .header-box p {
            margin: 0;
            font-size: 1.1em;
            opacity: 0.9;
        }
        /* Layout for displaying motor information in the header */
        .header-info {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 15px;
        }
        /* Styling for individual info items in the header */
        .header-info div {
            background-color: rgba(255,255,255,0.15);
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 0.9em;
            flex-basis: 200px; /* Base width for flex items */
        }
        /* Styling for strong text within header info */
        .header-info strong {
            display: block;
            font-size: 1.2em;
            margin-bottom: 3px;
        }

        /* Styling for navigation links */
        .navigation-links {
            margin-top: 20px;
        }
        /* Styling for navigation buttons */
        .nav-button {
            display: inline-block;
            background-color: #007bff;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            text-decoration: none;
            font-weight: bold;
            transition: background-color 0.3s ease;
            margin: 0 5px;
        }
        /* Hover effect for navigation buttons */
        .nav-button:hover {
            background-color: #0056b3;
        }

        /* Styling for the anomaly status display */
        .anomaly-status {
            padding: 15px 30px;
            border-radius: 0 0 10px 10px;
            font-size: 1.1em;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        /* Specific styling for no anomaly alert */
        .no-anomaly-alert {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        /* Specific styling for anomaly alert */
        .anomaly-alert {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        /* Layout for the main dashboard columns */
        .main-dashboard-columns {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            padding: 30px;
        }
        /* Styling for individual dashboard columns */
        .dashboard-column {
            flex: 1; /* Allows columns to grow and shrink */
            min-width: 45%; /* Minimum width to prevent excessive shrinking */
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        /* Styling for data panels */
        .data-panel {
            background-color: #f9fbfd;
            border: 1px solid #e0e6ed;
            border-radius: 8px;
            padding: 25px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            flex-grow: 0; /* Prevents panel from growing unnecessarily */
        }
        /* Heading styling within data panels */
        .data-panel h2 {
            color: #0056b3;
            margin-top: 0;
            border-bottom: 2px solid #e0e6ed;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        /* Styling for the motor display section */
        .motor-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
        }
        /* Styling for the motor image container */
        .motor-image {
            width: 180px;
            height: 180px;
            background-color: #ccc;
            border-radius: 50%; /* Makes image circular */
            overflow: hidden;
            margin-bottom: 15px;
            border: 3px solid #0056b3;
            box-shadow: 0 0 15px rgba(0,86,179,0.3);
        }
        /* Styling for the actual motor image */
        .motor-image img {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Ensures image covers the area */
        }
        /* Grid layout for displaying data items */
        .data-grid {
            display: grid;
            grid-template-columns: 1fr 1fr; /* Two columns */
            gap: 15px;
            text-align: left;
        }
        /* Styling for individual data items */
        .data-item {
            padding: 8px 0;
            border-bottom: 1px dashed #eee;
        }
        /* Padding for alternating data items */
        .data-item:nth-child(odd) {
            padding-right: 10px;
        }
        .data-item:nth-child(even) {
            padding-left: 10px;
        }
        /* Remove bottom border for last data items */
        .data-item:last-child, .data-grid div:nth-last-child(2) {
            border-bottom: none;
        }
        /* Styling for strong text in data items */
        .data-item strong {
            color: #004085;
        }
        /* Styling for span elements in data items (values) */
        .data-item span {
            float: right;
            font-weight: bold;
        }

        /* Styling for graph sections */
        .graph-section {
            background-color: #f9fbfd;
            border: 1px solid #e0e6ed;
            border-radius: 8px;
            padding: 25px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        /* Heading styling within graph sections */
        .graph-section h2 {
            color: #0056b3;
            border-bottom: 2px solid #e0e6ed;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        /* Container for multiple graphs */
        .graph-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: space-around;
        }
        /* Wrapper for individual charts */
        .chart-wrapper {
            flex: 1;
            min-width: 100%; /* Charts take full width on smaller screens */
            background: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            text-align: center;
            height: 350px; /* Fixed height for charts */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        /* Heading styling within chart wrappers */
        .chart-wrapper h3 {
            color: #0056b3;
            margin-top: 0;
            margin-bottom: 10px;
        }
        /* Styling for canvas elements (charts) */
        .chart-wrapper canvas {
            height: 280px;
            width: 100%;
            flex-grow: 1;
        }

        /* Styling for the time range selector section */
        .time-range-selector {
            background-color: #f9fbfd;
            border: 1px solid #e0e6ed;
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            text-align: center;
        }
        /* Label styling within time range selector */
        .time-range-selector label {
            margin-right: 10px;
            font-weight: bold;
            color: #0056b3;
        }
        /* Input field styling for date/time */
        .time-range-selector input[type="datetime-local"] {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-right: 10px;
            width: 200px;
        }
        /* Dropdown styling for time range selector */
        .time-range-selector select {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-right: 10px;
            width: 150px;
        }
        /* Button styling within time range selector */
        .time-range-selector button {
            background-color: #28a745;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s ease;
            margin: 5px;
        }
        /* Hover effect for time range selector buttons */
        .time-range-selector button:hover {
            background-color: #218838;
        }

        /* Footer styling */
        .footer {
            margin-top: 30px;
            text-align: center;
            color: #777;
            font-size: 0.85em;
            padding: 20px;
            background-color: #eef2f7;
            border-top: 1px solid #e0e6ed;
        }
        /* Link styling in the footer */
        .footer a {
            color: #0056b3;
            text-decoration: none;
        }
        /* Hover effect for footer links */
        .footer a:hover {
            text-decoration: underline;
        }

        /* Responsive design for smaller screens */
        @media (max-width: 768px) {
            /* Stack dashboard columns vertically */
            .main-dashboard-columns {
                flex-direction: column;
                padding: 15px;
            }
            /* Make columns take full width */
            .dashboard-column {
                min-width: 100%;
            }
            /* Stack header info items vertically */
            .header-info {
                flex-direction: column;
                align-items: stretch;
            }
            /* Center text in header info items */
            .header-info div {
                text-align: center;
            }
            /* Make data grid a single column */
            .data-grid {
                grid-template-columns: 1fr;
            }
            /* Remove padding for data items in single column layout */
            .data-item:nth-child(odd), .data-item:nth-child(even) {
                padding-left: 0;
                padding-right: 0;
            }
            /* Make chart wrappers take full width */
            .chart-wrapper {
                min-width: 100%;
            }
            /* Make time range inputs and buttons take full width */
            .time-range-selector input[type="datetime-local"],
            .time-range-selector select {
                width: 100%;
                margin-bottom: 10px;
            }
            .time-range-selector button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header section displaying motor name, model, description, and key information -->
        <div class="header-box">
            <h1>{{ motor_info.name }} {{ motor_info.model }} IoT Dashboard</h1>
            <p>{{ motor_info.description }}</p>
            <div class="header-info">
                <div><strong>Kennzeichnung:</strong> {{ motor_info.identification }}</div>
                <div><strong>Ort:</strong> {{ motor_info.location }}</div>
                <div><strong>Inbetriebnahme:</strong> {{ motor_info.commissioning_date|default:"N/A" }}</div>
                <div><strong>Betriebsmodus:</strong> {{ motor_info.operating_mode }}</div>
            </div>
            <!-- Navigation link to the malfunction log page -->
            <div class="navigation-links">
                <a href="{% url 'iot_app:malfunction_log' %}" class="nav-button">Störmeldungs-Log anzeigen</a>
            </div>
        </div>

        <!-- Anomaly status display, dynamically styled based on 'anomaly_status.detected' -->
        <div id="anomaly-status" class="anomaly-status {% if anomaly_status.detected %}anomaly-alert{% else %}no-anomaly-alert{% endif %}">
            {{ anomaly_status.message }}
        </div>

        <!-- Main dashboard content organized into two columns -->
        <div class="main-dashboard-columns">
            <!-- Left column for real motor data and graphs -->
            <div class="dashboard-column">
                <!-- Panel for current real motor data -->
                <div class="data-panel">
                    <h2>Aktuelle Motordaten</h2>
                    <div class="motor-display">
                        <!-- Image representing the real motor -->
                        <div class="motor-image">
                            <img src="{% static 'images/motor.png' %}" alt="Bild des Elektromotors">
                        </div>
                        <p>Echtzeitdaten vom Frequenzumrichter und angeschlossenen Sensoren.</p>
                    </div>
                     <!-- Grid displaying real-time sensor values -->
                    <div class="data-grid" id="real-motor-data-grid">
                        <div class="data-item"><strong>Strom:</strong> <span id="real-strom">{{ real_motor_data.Strom.value|default:'N/A' }} {{ real_motor_data.Strom.unit }}</span></div>
                        <div class="data-item"><strong>Spannung:</strong> <span id="real-spannung">{{ real_motor_data.Spannung.value|default:'N/A' }} {{ real_motor_data.Spannung.unit }}</span></div>
                        <div class="data-item"><strong>Drehzahl:</strong> <span id="real-drehzahl">{{ real_motor_data.Drehzahl.value|default:'N/A' }} {{ real_motor_data.Drehzahl.unit }}</span></div>
                        <div class="data-item"><strong>Vibration:</strong> <span id="real-vibration">{{ real_motor_data.Vibration.value|default:'N/A' }} {{ real_motor_data.Vibration.unit }}</span></div>
                        <div class="data-item"><strong>Temperatur:</strong> <span id="real-temperatur">{{ real_motor_data.Temperatur.value|default:'N/A' }} {{ real_motor_data.Temperatur.unit }}</span></div>
                        <div class="data-item"><strong>Drehmoment:</strong> <span id="real-drehmoment">{{ real_motor_data.Drehmoment.value|default:'N/A' }} {{ real_motor_data.Drehmoment.unit }}</span></div>
                        <div class="data-item"><strong>Anzahl eingefahren:</strong> <span id="real-anzahl-eingefahren">{{ real_motor_data.Anzahl_eingefahren.value|default:'N/A' }}</span></div>
                        <div class="data-item"><strong>Anzahl ausgefahren:</strong> <span id="real-anzahl-ausgefahren">{{ real_motor_data.Anzahl_ausgefahren.value|default:'N/A' }}</span></div>
                    </div>
                </div>

                <!-- Section for real motor data graphs -->
                <div class="graph-section">
                    <h2>Graphen des realen Motors</h2>
                    <div class="graph-container">
                        <!-- Chart for real current -->
                        <div class="chart-wrapper">
                            <h3>Stromverlauf über die Zeit (mit Features)</h3>
                            <canvas id="real-current-chart"></canvas>
                        </div>
                        <!-- Chart for real voltage -->
                        <div class="chart-wrapper">
                            <h3>Spannungsverlauf über die Zeit</h3>
                            <canvas id="real-voltage-chart"></canvas>
                        </div>
                        <!-- Chart for real torque -->
                        <div class="chart-wrapper">
                            <h3>Drehmomentverlauf über die Zeit (mit Features)</h3>
                            <canvas id="real-torque-chart"></canvas>
                        </div>
                        <!-- Chart for real temperature -->
                        <div class="chart-wrapper">
                            <h3>Temperaturverlauf über die Zeit (mit Features)</h3>
                            <canvas id="real-temp-chart"></canvas>
                        </div>
                        <!-- Chart for real RPM -->
                        <div class="chart-wrapper">
                            <h3>Drehzahlverlauf über die Zeit</h3>
                            <canvas id="real-rpm-chart"></canvas>
                        </div>
                        <!-- Chart for real vibration -->
                        <div class="chart-wrapper">
                            <h3>Vibrationsverlauf über die Zeit</h3>
                            <canvas id="real-vibration-chart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right column for digital twin data and graphs -->
            <div class="dashboard-column">
                <!-- Panel for digital twin (expected) data -->
                <div class="data-panel">
                    <h2>Digitaler Zwilling (Erwartete Werte)</h2>
                    <div class="motor-display">
                        <!-- Image representing the digital twin -->
                        <div class="motor-image">
                            <img src="{% static 'images/motor_twin.png' %}" alt="Bild des Digitalen Zwillings">
                        </div>
                        <p>Modellierte Werte basierend auf dem digitalen Zwillingsmodell.</p>
                    </div>
                     <!-- Grid displaying expected sensor values from the digital twin -->
                    <div class="data-grid" id="digital-twin-data-grid">
                        <div class="data-item"><strong>Strom:</strong> <span id="expected-strom">{{ digital_twin_data.Strom.value|default:'N/A' }} {{ digital_twin_data.Strom.unit }}</span></div>
                        <div class="data-item"><strong>Spannung:</strong> <span id="expected-spannung">{{ digital_twin_data.Spannung.value|default:'N/A' }} {{ digital_twin_data.Spannung.unit }}</span></div>
                        <div class="data-item"><strong>Drehzahl:</strong> <span id="expected-drehzahl">{{ digital_twin_data.Drehzahl.value|default:'N/A' }} {{ digital_twin_data.Drehzahl.unit }}</span></div>
                        <div class="data-item"><strong>Vibration:</strong> <span id="expected-vibration">{{ digital_twin_data.Vibration.value|default:'N/A' }} {{ digital_twin_data.Vibration.unit }}</span></div>
                        <div class="data-item"><strong>Temperatur:</strong> <span id="expected-temperatur">{{ digital_twin_data.Temperatur.value|default:'N/A' }} {{ digital_twin_data.Temperatur.unit }}</span></div>
                        <div class="data-item"><strong>Drehmoment:</strong> <span id="expected-drehmoment">{{ digital_twin_data.Drehmoment.value|default:'N/A' }} {{ digital_twin_data.Drehmoment.unit }}</span></div>
                        <div class="data-item"><strong>Anzahl eingefahren:</strong> <span id="expected-anzahl-eingefahren">{{ digital_twin_data.Anzahl_eingefahren.value|default:'N/A' }}</span></div>
                        <div class="data-item"><strong>Anzahl ausgefahren:</strong> <span id="expected-anzahl-ausgefahren">{{ digital_twin_data.Anzahl_ausgefahren.value|default:'N/A' }}</span></div>
                    </div>
                </div>

                <!-- Section for digital twin data graphs -->
                <div class="graph-section">
                    <h2>Graphen des digitalen Zwillings</h2>
                    <div class="graph-container">
                        <!-- Chart for digital twin current -->
                        <div class="chart-wrapper">
                            <h3>Stromverlauf über die Zeit (Modell)</h3>
                            <canvas id="dt-current-chart"></canvas>
                        </div>
                        <!-- Chart for digital twin voltage -->
                        <div class="chart-wrapper">
                            <h3>Spannungsverlauf über die Zeit (Modell)</h3>
                            <canvas id="dt-voltage-chart"></canvas>
                        </div>
                        <!-- Chart for digital twin torque -->
                        <div class="chart-wrapper">
                            <h3>Drehmomentverlauf über die Zeit (Modell)</h3>
                            <canvas id="dt-torque-chart"></canvas>
                        </div>
                        <!-- Chart for digital twin temperature -->
                        <div class="chart-wrapper">
                            <h3>Temperaturverlauf über die Zeit (Modell)</h3>
                            <canvas id="dt-temp-chart"></canvas>
                        </div>
                        <!-- Chart for digital twin RPM -->
                        <div class="chart-wrapper">
                            <h3>Drehzahlverlauf über die Zeit (Modell)</h3>
                            <canvas id="dt-rpm-chart"></canvas>
                        </div>
                        <!-- Chart for digital twin vibration -->
                        <div class="chart-wrapper">
                            <h3>Vibrationsverlauf über die Zeit (Modell)</h3>
                            <canvas id="dt-vibration-chart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Time range selector for plotting historical data -->
        <div class="time-range-selector">
            <h2>Plot-Zeitbereich auswählen</h2>
            <div>
                <label for="plot-start-time">Startzeit:</label>
                <input type="datetime-local" id="plot-start-time" step="1">
                <label for="plot-end-time">Endzeit:</label>
                <input type="datetime-local" id="plot-end-time" step="1">
                <label for="end-time-mode">Endzeit-Modus:</label>
                <select id="end-time-mode">
                    <option value="fixed">Festgelegt</option>
                    <option value="live">Live</option>
                </select>
                <button id="apply-time-range" class="nav-button">Anwenden</button>
                <button id="reset-time-range" class="nav-button">Aktuellen Lauf anzeigen</button>
            </div>
        </div>

        <!-- Footer section -->
        <div class="footer">
            <p>&copy; {{ current_year }} IoT Dashboard. Alle Rechte vorbehalten.</p>
            <p>Verwaltung: <a href="/admin/" target="_blank">Admin-Panel</a></p>
        </div>
    </div>

   <!-- Chart.js library for creating graphs -->
   <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
   <!-- Chart.js adapter for date-fns for time series data -->
   <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

   <script>
        // Determine WebSocket protocol based on current page's protocol
        const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
        // Construct WebSocket URL for the dashboard endpoint
        const ws_path = protocol + window.location.host + `/ws/dashboard/`;
        // Create a new WebSocket connection
        const socket = new WebSocket(ws_path);

        // Object to store Chart.js instances
        let charts = {};
        // Flag to indicate if the end time is set to "live"
        let liveEndTimeMode = false; // New flag to track if the current view is live-updating
        // Default time window for live mode in milliseconds (10 minutes)
        const LIVE_WINDOW_MS = 10 * 60 * 1000;

        // Configuration for shared Y-axis scales across corresponding charts
        const yAxisSharedGroups = {
            'current': {
                realChartId: 'real-current-chart',
                twinChartId: 'dt-current-chart',
                realDatasets: [
                    { datasetIndex: 0 }, // Raw Current
                    { datasetIndex: 1 }, // Mean
                    { datasetIndex: 2 }, // Min
                    { datasetIndex: 3 }, // Max
                    { datasetIndex: 4 }, // Median
                    { datasetIndex: 5 }, // Std
                ],
                twinDatasets: [
                    { datasetIndex: 0 }, // Twin Current
                    { datasetIndex: 1 }, // Twin Mean
                    { datasetIndex: 2 }, // Twin Min
                    { datasetIndex: 3 }, // Twin Max
                    { datasetIndex: 4 }, // Twin Median
                    { datasetIndex: 5 }, // Twin Std
                ],
                yAxisID: 'y'
            },
            'voltage': {
                realChartId: 'real-voltage-chart', realDatasets: [{ datasetIndex: 0 }], // Live Voltage
                twinChartId: 'dt-voltage-chart', twinDatasets: [{ datasetIndex: 0 }], // Twin Voltage
                yAxisID: 'y'
            },
            'torque': {
                realChartId: 'real-torque-chart',
                twinChartId: 'dt-torque-chart',
                realDatasets: [
                    { datasetIndex: 0 }, // Raw Torque
                    { datasetIndex: 1 }, // Mean
                    { datasetIndex: 2 }, // Min
                    { datasetIndex: 3 }, // Max
                    { datasetIndex: 4 }, // Median
                    { datasetIndex: 5 }, // Std
                ],
                twinDatasets: [
                    { datasetIndex: 0 }, // Twin Torque
                    { datasetIndex: 1 }, // Twin Mean
                    { datasetIndex: 2 }, // Twin Min
                    { datasetIndex: 3 }, // Twin Max
                    { datasetIndex: 4 }, // Twin Median
                    { datasetIndex: 5 }, // Twin Std
                ],
                yAxisID: 'y'
            },
            'temp': {
                realChartId: 'real-temp-chart',
                twinChartId: 'dt-temp-chart',
                realDatasets: [
                    { datasetIndex: 0 }, // Raw Temperature
                    { datasetIndex: 1 }, // Mean
                    { datasetIndex: 2 }, // Min
                    { datasetIndex: 3 }, // Max
                    { datasetIndex: 4 }, // Median
                    { datasetIndex: 5 }, // Std
                ],
                twinDatasets: [
                    { datasetIndex: 0 }, // Twin Temperature
                    { datasetIndex: 1 }, // Twin Mean
                    { datasetIndex: 2 }, // Twin Min
                    { datasetIndex: 3 }, // Twin Max
                    { datasetIndex: 4 }, // Twin Median
                    { datasetIndex: 5 }, // Twin Std
                ],
                yAxisID: 'y'
            },
            'rpm': {
                realChartId: 'real-rpm-chart', realDatasets: [{ datasetIndex: 0 }], // Live RPM
                twinChartId: 'dt-rpm-chart', twinDatasets: [{ datasetIndex: 0 }], // Twin RPM
                yAxisID: 'y'
            },
            'vibration': {
                realChartId: 'real-vibration-chart', realDatasets: [{ datasetIndex: 0 }], // Live Vibration
                twinChartId: 'dt-vibration-chart', twinDatasets: [{ datasetIndex: 0 }], // Twin Vibration
                yAxisID: 'y'
            }
        };

        /**
         * Converts a string to a URL-friendly slug format.
         * @param {string} text - The input string.
         * @returns {string} The slugified string.
         */
        function createSlug(text) {
            return text.toLowerCase()
                       .replace(/[\s_]+/g, '-') // Replace spaces/underscores with hyphens
                       .replace(/[^a-z0-9-]+/g, '') // Remove non-alphanumeric characters except hyphens
                       .replace(/^-*|-*$/g, ''); // Trim leading/trailing hyphens
        }

        /**
         * Initializes a Chart.js chart on a given canvas.
         * @param {string} canvasId - The ID of the canvas element.
         * @param {string} title - The title of the chart.
         * @param {Array<Object>} datasetsConfig - An array of dataset configurations.
         * @param {Object} chartOptions - Additional Chart.js options to merge.
         * @returns {Chart} The initialized Chart.js instance.
         */
        function initializeChart(canvasId, title, datasetsConfig, chartOptions = {}) {
            // Get the 2D rendering context of the canvas
            const ctx = document.getElementById(canvasId).getContext('2d');
            // Default options for all charts
            const defaultOptions = {
                responsive: true,
                maintainAspectRatio: false,
                animation: { duration: 0 }, // Disable animation for real-time updates
                plugins: {
                    legend: { display: true },
                    tooltip: { mode: 'index', intersect: false }
                },
                scales: {
                    x: {
                        type: 'time', // X-axis is time-based
                        time: {
                            unit: 'second',
                            displayFormats: { second: 'HH:mm:ss' }
                        },
                        title: { display: true, text: 'Zeit' },
                        min: undefined, // Will be set dynamically
                        max: undefined, // Will be set dynamically
                    }
                }
            };

            // Merge default options with any provided custom options
            const mergedOptions = {
                ...defaultOptions,
                ...chartOptions,
                scales: {
                    ...defaultOptions.scales,
                    ...(chartOptions.scales || {}) // Merge scales specifically
                }
            };

            // Create a new Chart.js instance
            const newChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: datasetsConfig.map(ds => ({
                        label: ds.label,
                        data: [], // Initial empty data array
                        borderColor: ds.borderColor,
                        backgroundColor: ds.backgroundColor || 'rgba(0, 0, 0, 0)', // Transparent background by default
                        borderWidth: ds.borderWidth || 2,
                        pointRadius: ds.pointRadius || 0, // No points displayed by default
                        pointBackgroundColor: ds.pointBackgroundColor || ds.borderColor,
                        pointStyle: ds.pointStyle || 'circle', // Default point style
                        tension: ds.tension || 0.1, // Smooth line tension
                        yAxisID: ds.yAxisID || 'y', // Default Y-axis ID
                        borderDash: ds.borderDash || [],
                        showLine: ds.showLine !== undefined ? ds.showLine : true, // Show line by default
                    }))
                },
                options: mergedOptions
            });
            // Store the chart instance in the global 'charts' object
            charts[canvasId] = newChart;
            return newChart;
        }

        /**
         * Applies shared Y-axis scaling across corresponding charts.
         * This ensures that the Y-axis range is consistent for related metrics.
         */
        function applySharedYAxisScale() {
            for (const metricKey in yAxisSharedGroups) {
                const group = yAxisSharedGroups[metricKey];
                const realChart = charts[group.realChartId];
                const twinChart = charts[group.twinChartId];

                const allYValues = [];

                // Collect data from real chart datasets
                if (realChart && group.realDatasets) {
                    group.realDatasets.forEach(ds => {
                        if (realChart.data.datasets[ds.datasetIndex]) {
                            realChart.data.datasets[ds.datasetIndex].data.forEach(p => allYValues.push(p.y));
                        }
                    });
                }
                // Collect data from twin chart datasets
                if (twinChart && group.twinDatasets) {
                    group.twinDatasets.forEach(ds => {
                        if (twinChart.data.datasets[ds.datasetIndex]) {
                            twinChart.data.datasets[ds.datasetIndex].data.forEach(p => allYValues.push(p.y));
                        }
                    });
                }

                if (allYValues.length > 0) {
                    let minVal = Math.min(...allYValues);
                    let maxVal = Math.max(...allYValues);

                    const padding = (maxVal - minVal) * 0.1;
                    minVal = minVal - padding;
                    maxVal = maxVal + padding;

                    if (minVal < 0 && Math.min(...allYValues) >= 0) minVal = 0;

                    // Apply to real chart
                    if (realChart && realChart.options.scales[group.yAxisID]) {
                        realChart.options.scales[group.yAxisID].min = minVal;
                        realChart.options.scales[group.yAxisID].max = maxVal;
                        realChart.update('none');
                    }
                    // Apply to twin chart
                    if (twinChart && twinChart.options.scales[group.yAxisID]) {
                        twinChart.options.scales[group.yAxisID].min = minVal;
                        twinChart.options.scales[group.yAxisID].max = maxVal;
                        twinChart.update('none');
                    }
                } else {
                    // Reset to auto-scaling if no data
                    if (realChart && realChart.options.scales[group.yAxisID]) {
                        realChart.options.scales[group.yAxisID].min = undefined;
                        realChart.options.scales[group.yAxisID].max = undefined;
                        realChart.update('none');
                    }
                    if (twinChart && twinChart.options.scales[group.yAxisID]) {
                        twinChart.options.scales[group.yAxisID].min = undefined;
                        twinChart.options.scales[group.yAxisID].max = undefined;
                        twinChart.update('none');
                    }
                }
            }
        }

        /**
         * Updates the UI elements (data values and anomaly status) with new data.
         * @param {Object} data - The data object received from the WebSocket.
         */
        function updateUI(data) {
            // Update real motor data
            if (data.real_motor_data) {
                const realData = data.real_motor_data;
                for (const key in realData) {
                    const slugifiedKey = createSlug(key);
                    const elementId = `real-${slugifiedKey}`;
                    const element = document.getElementById(elementId);
                    if (element) {
                        const newValue = realData[key].value !== null ? realData[key].value : 'N/A';
                        element.textContent = `${newValue} ${realData[key].unit}`;
                    }
                }
            }

            // Update digital twin data
            if (data.digital_twin_data) {
                const twinData = data.digital_twin_data;
                for (const key in twinData) {
                    const slugifiedKey = createSlug(key);
                    const elementId = `expected-${slugifiedKey}`;
                    const element = document.getElementById(elementId);
                    if (element) {
                        const newValue = twinData[key].value !== null ? twinData[key].value : 'N/A';
                        element.textContent = `${newValue} ${twinData[key].unit}`;
                    }
                }
            }

            // Update anomaly status
            if (data.anomaly_status) {
                const anomalyStatusElement = document.getElementById('anomaly-status');
                const anomaly = data.anomaly_status;
                if (anomalyStatusElement) {
                    anomalyStatusElement.textContent = anomaly.message;
                    // Apply appropriate CSS class based on anomaly detection
                    if (anomaly.detected) {
                        anomalyStatusElement.className = 'anomaly-status anomaly-alert';
                    } else {
                        anomalyStatusElement.className = 'anomaly-status no-anomaly-alert';
                    }
                }
            }
        }

        /**
         * Returns the background color for a data point based on its prediction status.
         * @param {number} prediction - The prediction status (-1 for bad, 1 for good, 0 or null for neutral).
         * @returns {string} The color string.
         */
        const getPointBackgroundColor = (prediction) => {
            if (prediction === 1) return 'green'; // Good value
            if (prediction === -1) return 'red'; // Bad value
            return 'blue'; // Default color if no prediction or 0
        };

        /**
         * Returns the point style for a data point based on its prediction status.
         * @param {number} prediction - The prediction status (-1 for bad, 1 for good, 0 or null for neutral).
         * @returns {string} The point style string ('circle', 'cross', etc.).
         */
        const getPointStyle = (prediction) => {
            if (prediction === -1) return 'cross'; // Bad value as a cross
            return 'circle'; // Good or neutral value as a circle
        };

        /**
         * Updates all charts with historical data received from the server.
         * Clears existing chart data and repopulates with the new historical data.
         * @param {Object} plotData - Historical data for live, twin, raw, and feature metrics.
         * @param {string} plotType - Type of plot data (e.g., 'initial_historical', 'historical_range', 'initial_live_10_min').
         * @param {string} startTime - The start time of the historical data range.
         * @param {string} endTime - The end time of the historical data range.
         * @param {boolean} isLiveModeActive - Indicates if the backend considers this a live-updating view.
         */
        function updateChartsWithHistoricalData(plotData, plotType, startTime, endTime, isLiveModeActive) {
            console.log("Updating charts with historical data. Live mode active:", isLiveModeActive);
            // Clear all existing chart data
            Object.values(charts).forEach(chart => {
                chart.data.datasets.forEach(dataset => {
                    dataset.data = [];
                });
            });

            // Populate real motor charts with historical data
            // Prioritize raw data for current, temperature, torque
            if (plotData.raw) {
                if (plotData.raw.current) {
                    const dataset = charts['real-current-chart'].data.datasets[0];
                    dataset.data = plotData.raw.current.map(p => ({
                        x: new Date(p.x),
                        y: p.y,
                        pointBackgroundColor: getPointBackgroundColor(p.prediction),
                        pointStyle: getPointStyle(p.prediction),
                        pointRadius: 1 // Ensure points are visible for raw data
                    }));
                }
                if (plotData.raw.temperature) {
                    const dataset = charts['real-temp-chart'].data.datasets[0];
                    dataset.data = plotData.raw.temperature.map(p => ({
                        x: new Date(p.x),
                        y: p.y,
                        pointBackgroundColor: getPointBackgroundColor(p.prediction),
                        pointStyle: getPointStyle(p.prediction),
                        pointRadius: 1 // Ensure points are visible for raw data
                    }));
                }
                if (plotData.raw.torque) {
                    const dataset = charts['real-torque-chart'].data.datasets[0];
                    dataset.data = plotData.raw.torque.map(p => ({
                        x: new Date(p.x),
                        y: p.y,
                        pointBackgroundColor: getPointBackgroundColor(p.prediction),
                        pointStyle: getPointStyle(p.prediction),
                        pointRadius: 1 // Ensure points are visible for raw data
                    }));
                }
            }
            // Use live data for voltage, rpm, vibration, and as fallback for current/temp/torque if raw is missing
            if (plotData.live) {
                if (plotData.live.voltage) charts['real-voltage-chart'].data.datasets[0].data = plotData.live.voltage.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.live.rpm) charts['real-rpm-chart'].data.datasets[0].data = plotData.live.rpm.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.live.vibration) charts['real-vibration-chart'].data.datasets[0].data = plotData.live.vibration.map(p => ({x: new Date(p.x), y: p.y}));

                // Fallback for current, temp, torque if raw data was not available or empty
                // Note: Fallback live data points will have default blue circle style as they don't have prediction
                if (!plotData.raw || !plotData.raw.current || plotData.raw.current.length === 0) {
                    if (plotData.live.current) {
                        const dataset = charts['real-current-chart'].data.datasets[0];
                        dataset.data = plotData.live.current.map(p => ({x: new Date(p.x), y: p.y}));
                    }
                }
                if (!plotData.raw || !plotData.raw.temperature || plotData.raw.temperature.length === 0) {
                    if (plotData.live.temp) {
                        const dataset = charts['real-temp-chart'].data.datasets[0];
                        dataset.data = plotData.live.temp.map(p => ({x: new Date(p.x), y: p.y}));
                    }
                }
                if (!plotData.raw || !plotData.raw.torque || plotData.raw.torque.length === 0) {
                    if (plotData.live.torque) {
                        const dataset = charts['real-torque-chart'].data.datasets[0];
                        dataset.data = plotData.live.torque.map(p => ({x: new Date(p.x), y: p.y}));
                    }
                }
            }

            // Populate digital twin charts with historical data
            if (plotData.twin) {
                if (plotData.twin.current) charts['dt-current-chart'].data.datasets[0].data = plotData.twin.current.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.twin.voltage) charts['dt-voltage-chart'].data.datasets[0].data = plotData.twin.voltage.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.twin.rpm) charts['dt-rpm-chart'].data.datasets[0].data = plotData.twin.rpm.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.twin.vibration) charts['dt-vibration-chart'].data.datasets[0].data = plotData.twin.vibration.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.twin.temp) charts['dt-temp-chart'].data.datasets[0].data = plotData.twin.temp.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.twin.torque) charts['dt-torque-chart'].data.datasets[0].data = plotData.twin.torque.map(p => ({x: new Date(p.x), y: p.y}));
            }

            // Populate feature data into the respective real data charts
            if (plotData.feature) {
                // Temperature Features (Real)
                if (plotData.feature.temperature_mean) charts['real-temp-chart'].data.datasets[1].data = plotData.feature.temperature_mean.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.temperature_min) charts['real-temp-chart'].data.datasets[2].data = plotData.feature.temperature_min.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.temperature_max) charts['real-temp-chart'].data.datasets[3].data = plotData.feature.temperature_max.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.temperature_median) charts['real-temp-chart'].data.datasets[4].data = plotData.feature.temperature_median.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.temperature_std) charts['real-temp-chart'].data.datasets[5].data = plotData.feature.temperature_std.map(p => ({x: new Date(p.x), y: p.y}));

                // Current Features (Real)
                if (plotData.feature.current_mean) charts['real-current-chart'].data.datasets[1].data = plotData.feature.current_mean.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.current_min) charts['real-current-chart'].data.datasets[2].data = plotData.feature.current_min.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.current_max) charts['real-current-chart'].data.datasets[3].data = plotData.feature.current_max.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.current_median) charts['real-current-chart'].data.datasets[4].data = plotData.feature.current_median.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.current_std) charts['real-current-chart'].data.datasets[5].data = plotData.feature.current_std.map(p => ({x: new Date(p.x), y: p.y}));

                // Torque Features (Real)
                if (plotData.feature.torque_mean) charts['real-torque-chart'].data.datasets[1].data = plotData.feature.torque_mean.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.torque_min) charts['real-torque-chart'].data.datasets[2].data = plotData.feature.torque_min.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.torque_max) charts['real-torque-chart'].data.datasets[3].data = plotData.feature.torque_max.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.torque_median) charts['real-torque-chart'].data.datasets[4].data = plotData.feature.torque_median.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.torque_std) charts['real-torque-chart'].data.datasets[5].data = plotData.feature.torque_std.map(p => ({x: new Date(p.x), y: p.y}));

                // Temperature Features (Twin)
                if (plotData.feature.temperature_mean) charts['dt-temp-chart'].data.datasets[1].data = plotData.feature.temperature_mean.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.temperature_min) charts['dt-temp-chart'].data.datasets[2].data = plotData.feature.temperature_min.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.temperature_max) charts['dt-temp-chart'].data.datasets[3].data = plotData.feature.temperature_max.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.temperature_median) charts['dt-temp-chart'].data.datasets[4].data = plotData.feature.temperature_median.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.temperature_std) charts['dt-temp-chart'].data.datasets[5].data = plotData.feature.temperature_std.map(p => ({x: new Date(p.x), y: p.y}));

                // Current Features (Twin)
                if (plotData.feature.current_mean) charts['dt-current-chart'].data.datasets[1].data = plotData.feature.current_mean.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.current_min) charts['dt-current-chart'].data.datasets[2].data = plotData.feature.current_min.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.current_max) charts['dt-current-chart'].data.datasets[3].data = plotData.feature.current_max.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.current_median) charts['dt-current-chart'].data.datasets[4].data = plotData.feature.current_median.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.current_std) charts['dt-current-chart'].data.datasets[5].data = plotData.feature.current_std.map(p => ({x: new Date(p.x), y: p.y}));

                // Torque Features (Twin)
                if (plotData.feature.torque_mean) charts['dt-torque-chart'].data.datasets[1].data = plotData.feature.torque_mean.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.torque_min) charts['dt-torque-chart'].data.datasets[2].data = plotData.feature.torque_min.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.torque_max) charts['dt-torque-chart'].data.datasets[3].data = plotData.feature.torque_max.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.torque_median) charts['dt-torque-chart'].data.datasets[4].data = plotData.feature.torque_median.map(p => ({x: new Date(p.x), y: p.y}));
                if (plotData.feature.torque_std) charts['dt-torque-chart'].data.datasets[5].data = plotData.feature.torque_std.map(p => ({x: new Date(p.x), y: p.y}));
            }

            // Update time range input fields and flags
            liveEndTimeMode = isLiveModeActive; // Set based on backend's live_mode_active

            Object.values(charts).forEach(chart => {
                if (isLiveModeActive) {
                    // For live mode, set the X-axis to a dynamic 10-minute window
                    const now = new Date();
                    chart.options.scales.x.max = now;
                    chart.options.scales.x.min = new Date(now.getTime() - LIVE_WINDOW_MS);
                    console.log(`Chart ${chart.canvas.id} set to live mode: min=${chart.options.scales.x.min.toLocaleTimeString()}, max=${chart.options.scales.x.max.toLocaleTimeString()}`);
                } else if (startTime && endTime) {
                    // For fixed historical range, set min/max from provided times
                    chart.options.scales.x.min = new Date(startTime);
                    chart.options.scales.x.max = new Date(endTime);
                    console.log(`Chart ${chart.canvas.id} set to fixed range: min=${chart.options.scales.x.min.toLocaleTimeString()}, max=${chart.options.scales.x.max.toLocaleTimeString()}`);
                } else {
                    // Fallback to auto-scaling if no specific range and not in live mode
                    chart.options.scales.x.min = undefined;
                    chart.options.scales.x.max = undefined;
                    console.log(`Chart ${chart.canvas.id} set to auto-scale.`);
                }
                chart.update('none'); // Update charts without animation
            });

            // Apply shared Y-axis scaling after updating data
            applySharedYAxisScale();

            // Update the time range selector UI
            document.getElementById('plot-start-time').value = startTime ? new Date(startTime).toISOString().slice(0, 19) : '';
            // Corrected: handle 'live' string for endTime
            document.getElementById('plot-end-time').value = (endTime && endTime !== 'live') ? new Date(endTime).toISOString().slice(0, 19) : '';
            document.getElementById('end-time-mode').value = isLiveModeActive ? 'live' : 'fixed';
            document.getElementById('plot-end-time').disabled = isLiveModeActive; // Disable if in live mode
            console.log(`UI updated: liveEndTimeMode=${liveEndTimeMode}, plot-start-time=${document.getElementById('plot-start-time').value}, plot-end-time=${document.getElementById('plot-end-time').value}, end-time-mode=${document.getElementById('end-time-mode').value}`);
        }

        /**
         * Adds a single new data point to the end of all relevant real-time charts.
         * This function is skipped if a manual time range is active and not in live end time mode.
         * @param {Object} dataPoint - The latest data point containing live and twin metric values.
         */
        function addLatestDataPoint(dataPoint) {
            console.log("Received new data point:", dataPoint);
            // Only update charts with new live data if liveEndTimeMode is active
            if (!liveEndTimeMode) {
                console.log("Live mode is not active, skipping data point addition.");
                return;
            }

            const now = new Date();
            const minTime = now.getTime() - LIVE_WINDOW_MS;
            console.log(`Current time: ${now.toLocaleTimeString()}, Min time for window: ${new Date(minTime).toLocaleTimeString()}`);

            // Define a more robust mapping from dataPoint keys to chart IDs and dataset indices
            const chartDataMappings = {
                'real-current-chart': {
                    raw: { dataKey: 'raw', metric: 'current', datasetIndex: 0 },
                    mean: { dataKey: 'feature', metric: 'current_mean', datasetIndex: 1 },
                    min: { dataKey: 'feature', metric: 'current_min', datasetIndex: 2 },
                    max: { dataKey: 'feature', metric: 'current_max', datasetIndex: 3 },
                    median: { dataKey: 'feature', metric: 'current_median', datasetIndex: 4 },
                    std: { dataKey: 'feature', metric: 'current_std', datasetIndex: 5 },
                },
                'real-voltage-chart': {
                    live: { dataKey: 'live', metric: 'voltage', datasetIndex: 0 },
                },
                'real-rpm-chart': {
                    live: { dataKey: 'live', metric: 'rpm', datasetIndex: 0 },
                },
                'real-vibration-chart': {
                    live: { dataKey: 'live', metric: 'vibration', datasetIndex: 0 },
                },
                'real-temp-chart': {
                    raw: { dataKey: 'raw', metric: 'temperature', datasetIndex: 0 },
                    mean: { dataKey: 'feature', metric: 'temperature_mean', datasetIndex: 1 },
                    min: { dataKey: 'feature', metric: 'temperature_min', datasetIndex: 2 },
                    max: { dataKey: 'feature', metric: 'temperature_max', datasetIndex: 3 },
                    median: { dataKey: 'feature', metric: 'temperature_median', datasetIndex: 4 },
                    std: { dataKey: 'feature', metric: 'temperature_std', datasetIndex: 5 },
                },
                'real-torque-chart': {
                    raw: { dataKey: 'raw', metric: 'torque', datasetIndex: 0 },
                    mean: { dataKey: 'feature', metric: 'torque_mean', datasetIndex: 1 },
                    min: { dataKey: 'feature', metric: 'torque_min', datasetIndex: 2 },
                    max: { dataKey: 'feature', metric: 'torque_max', datasetIndex: 3 },
                    median: { dataKey: 'feature', metric: 'torque_median', datasetIndex: 4 },
                    std: { dataKey: 'feature', metric: 'torque_std', datasetIndex: 5 },
                },
                'dt-current-chart': {
                    twin: { dataKey: 'twin', metric: 'current', datasetIndex: 0 },
                    mean: { dataKey: 'feature', metric: 'current_mean', datasetIndex: 1 }, // Assuming twin also has features
                    min: { dataKey: 'feature', metric: 'current_min', datasetIndex: 2 },
                    max: { dataKey: 'feature', metric: 'current_max', datasetIndex: 3 },
                    median: { dataKey: 'feature', metric: 'current_median', datasetIndex: 4 },
                    std: { dataKey: 'feature', metric: 'current_std', datasetIndex: 5 },
                },
                'dt-voltage-chart': {
                    twin: { dataKey: 'twin', metric: 'voltage', datasetIndex: 0 },
                },
                'dt-rpm-chart': {
                    twin: { dataKey: 'twin', metric: 'rpm', datasetIndex: 0 },
                },
                'dt-vibration-chart': {
                    twin: { dataKey: 'twin', metric: 'vibration', datasetIndex: 0 },
                },
                'dt-temp-chart': {
                    twin: { dataKey: 'twin', metric: 'temperature', datasetIndex: 0 },
                    mean: { dataKey: 'feature', metric: 'temperature_mean', datasetIndex: 1 },
                    min: { dataKey: 'feature', metric: 'temperature_min', datasetIndex: 2 },
                    max: { dataKey: 'feature', metric: 'temperature_max', datasetIndex: 3 },
                    median: { dataKey: 'feature', metric: 'temperature_median', datasetIndex: 4 },
                    std: { dataKey: 'feature', metric: 'temperature_std', datasetIndex: 5 },
                },
                'dt-torque-chart': {
                    twin: { dataKey: 'twin', metric: 'torque', datasetIndex: 0 },
                    mean: { dataKey: 'feature', metric: 'torque_mean', datasetIndex: 1 },
                    min: { dataKey: 'feature', metric: 'torque_min', datasetIndex: 2 },
                    max: { dataKey: 'feature', metric: 'torque_max', datasetIndex: 3 },
                    median: { dataKey: 'feature', metric: 'torque_median', datasetIndex: 4 },
                    std: { dataKey: 'feature', metric: 'torque_std', datasetIndex: 5 },
                },
            };

            for (const chartId in chartDataMappings) {
                const chart = charts[chartId];
                if (!chart) {
                    console.warn(`Chart with ID ${chartId} not found.`);
                    continue; // Skip if chart not initialized
                }

                // Update X-axis min/max for the sliding window
                chart.options.scales.x.max = now;
                chart.options.scales.x.min = new Date(minTime);

                const mappings = chartDataMappings[chartId];

                for (const mappingType in mappings) {
                    const mapping = mappings[mappingType];
                    const dataset = chart.data.datasets[mapping.datasetIndex];
                    if (!dataset) {
                        console.warn(`Dataset ${mapping.datasetIndex} not found for chart ${chartId}.`);
                        continue; // Skip if dataset doesn't exist
                    }

                    let sourceData = dataPoint[mapping.dataKey];
                    let value = null;
                    let timestamp = null;
                    let predictionStatus = null;

                    if (sourceData && sourceData[mapping.metric]) {
                        value = sourceData[mapping.metric].y;
                        timestamp = new Date(sourceData[mapping.metric].x);
                        // Only raw data points have prediction status directly attached
                        if (mapping.dataKey === 'raw' && sourceData[mapping.metric].prediction !== undefined) {
                            predictionStatus = sourceData[mapping.metric].prediction;
                        }
                    } else if (mapping.dataKey === 'raw' && dataPoint.live && dataPoint.live[mapping.metric]) {
                        // Fallback for raw data if live data is available and raw is not
                        value = dataPoint.live[mapping.metric].y;
                        timestamp = new Date(dataPoint.live[mapping.metric].x);
                        // No prediction status for fallback live data
                    }

                    if (value !== null && timestamp) {
                        const newPoint = { x: timestamp, y: value };
                        if (predictionStatus !== null) {
                            newPoint.pointBackgroundColor = getPointBackgroundColor(predictionStatus);
                            newPoint.pointStyle = getPointStyle(predictionStatus);
                            newPoint.pointRadius = 3; // Make points visible for raw data with prediction
                        } else if (mapping.dataKey === 'raw' || mapping.dataKey === 'feature') {
                             newPoint.pointRadius = 1; // Ensure raw and feature data points are visible even without prediction
                        }

                        dataset.data.push(newPoint);
                        // console.log(`Added point to ${chartId} - ${dataset.label}: x=${newPoint.x.toLocaleTimeString()}, y=${newPoint.y}`);

                        // Remove data points older than the current chart's min X-axis value
                        while (dataset.data.length > 0 && dataset.data[0].x.getTime() < minTime) {
                            dataset.data.shift();
                            // console.log(`Shifted point from ${chartId} - ${dataset.label}`);
                        }
                    }
                    chart.update('none'); // Update chart after each dataset modification
                }
            }
            applySharedYAxisScale(); // Re-apply shared Y-axis scaling
        }

        // Event listener for when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Define a consistent color palette for each metric type and its features
            const colors = {
                raw: 'rgb(0, 150, 136)',        // Teal for raw current
                mean: 'rgb(255, 159, 64)',      // Orange for mean
                min: 'rgb(75, 192, 192)',       // Light Teal for min
                max: 'rgb(255, 99, 132)',       // Red for max
                median: 'rgb(54, 162, 235)',    // Blue for median
                std: 'rgb(153, 102, 255)',      // Purple for std
                voltage: 'rgb(255, 99, 132)',   // Red for voltage
                rpm: 'rgb(54, 162, 235)',       // Blue for RPM
                vibration: 'rgb(255, 205, 86)', // Yellow for vibration
                temperature: 'rgb(153, 102, 255)', // Purple for raw temperature
                torque: 'rgb(255, 159, 64)'     // Orange for raw torque
            };

            // Initialize real motor current chart
            initializeChart('real-current-chart', 'Stromverlauf über die Zeit (mit Features)', [
                { label: 'Strom (Raw)', borderColor: colors.raw, pointRadius: 1, showLine: false },
                { label: 'Strom Mean', borderColor: colors.mean, borderWidth: 2, tension: 0.3, pointRadius: 1 },
                { label: 'Strom Min', borderColor: colors.min, borderWidth: 1, borderDash: [2, 2], pointRadius: 1 },
                { label: 'Strom Max', borderColor: colors.max, borderWidth: 1, borderDash: [2, 2], pointRadius: 1 },
                { label: 'Strom Median', borderColor: colors.median, borderWidth: 1, borderDash: [5, 5], pointRadius: 1 },
                { label: 'Strom Std', borderColor: colors.std, borderWidth: 1, borderDash: [1, 1], pointRadius: 1 }
            ], {
                scales: {
                    y: {
                        title: { display: true, text: 'Strom (A)' },
                        beginAtZero: false
                    }
                }
            });

            // Initialize real motor voltage chart
            initializeChart('real-voltage-chart', 'Spannungsverlauf über die Zeit', [
                { label: 'Spannung (V)', borderColor: colors.voltage }
            ], {
                scales: {
                    y: {
                        title: { display: true, text: 'Spannung (V)' },
                        beginAtZero: false
                    }
                }
            });

            // Initialize real motor RPM chart
            initializeChart('real-rpm-chart', 'Drehzahlverlauf über die Zeit', [
                { label: 'Drehzahl (U/min)', borderColor: colors.rpm }
            ], {
                scales: {
                    y: {
                        title: { display: true, text: 'Drehzahl (U/min)' },
                        beginAtZero: false
                    }
                }
            });
            // Initialize real motor vibration chart
            initializeChart('real-vibration-chart', 'Vibrationsverlauf über die Zeit', [
                { label: 'Vibration (mm/s)', borderColor: colors.vibration }
            ], {
                scales: {
                    y: {
                        title: { display: true, text: 'Vibration (mm/s)' },
                        beginAtZero: false
                    }
                }
            });
            // Initialize real motor temperature chart
            initializeChart('real-temp-chart', 'Temperaturverlauf über die Zeit (mit Features)', [
                { label: 'Temperatur (Raw)', borderColor: colors.temperature, pointRadius: 1, showLine: false },
                { label: 'Temperatur Mean', borderColor: colors.mean, borderWidth: 2, tension: 0.3, pointRadius: 1 },
                { label: 'Temperatur Min', borderColor: colors.min, borderWidth: 1, borderDash: [2, 2], pointRadius: 1 },
                { label: 'Temperatur Max', borderColor: colors.max, borderWidth: 1, borderDash: [2, 2], pointRadius: 1 },
                { label: 'Temperatur Median', borderColor: colors.median, borderWidth: 1, borderDash: [5, 5], pointRadius: 1 },
                { label: 'Temperatur Std', borderColor: colors.std, borderWidth: 1, borderDash: [1, 1], pointRadius: 1 }
            ], {
                scales: {
                    y: {
                        title: { display: true, text: 'Temperatur (°C)' },
                        beginAtZero: false
                    }
                }
            });
            // Initialize real motor torque chart
            initializeChart('real-torque-chart', 'Drehmomentverlauf über die Zeit (mit Features)', [
                { label: 'Drehmoment (Raw)', borderColor: colors.raw, pointRadius: 1, showLine: false },
                { label: 'Drehmoment Mean', borderColor: colors.mean, borderWidth: 2, tension: 0.3, pointRadius: 1 },
                { label: 'Drehmoment Min', borderColor: colors.min, borderWidth: 1, borderDash: [2, 2], pointRadius: 1 },
                { label: 'Drehmoment Max', borderColor: colors.max, borderWidth: 1, borderDash: [2, 2], pointRadius: 1 },
                { label: 'Drehmoment Median', borderColor: colors.median, borderWidth: 1, borderDash: [5, 5], pointRadius: 1 },
                { label: 'Drehmoment Std', borderColor: colors.std, borderWidth: 1, borderDash: [1, 1], pointRadius: 1 }
            ], {
                scales: {
                    y: {
                        title: { display: true, text: 'Drehmoment (Nm)' },
                        beginAtZero: false
                    }
                }
            });

            // Initialize digital twin current chart with dashed lines
            initializeChart('dt-current-chart', 'Stromverlauf über die Zeit (Modell)', [
                { label: 'Strom (A) ', borderColor: colors.raw },
                { label: 'Strom Mean ', borderColor: colors.mean, borderWidth: 2, tension: 0.3 },
                { label: 'Strom Min ', borderColor: colors.min, borderWidth: 1, borderDash: [2, 2] },
                { label: 'Strom Max ', borderColor: colors.max, borderWidth: 1, borderDash: [2, 2] },
                { label: 'Strom Median ', borderColor: colors.median, borderWidth: 1, borderDash: [5, 5] },
                { label: 'Strom Std ', borderColor: colors.std, borderWidth: 1, borderDash: [1, 1] }
            ], {
                scales: {
                    y: {
                        title: { display: true, text: 'Strom (A)' },
                        beginAtZero: false
                    }
                }
            });

            // Initialize digital twin voltage chart with dashed lines
            initializeChart('dt-voltage-chart', 'Spannungsverlauf über die Zeit (Modell)', [
                { label: 'Spannung (V) ', borderColor: colors.voltage }
            ], {
                scales: {
                    y: {
                        title: { display: true, text: 'Spannung (V)' },
                        beginAtZero: false
                    }
                }
            });

            // Initialize digital twin RPM chart with dashed lines
            initializeChart('dt-rpm-chart', 'Drehzahlverlauf über die Zeit (Modell)', [
                { label: 'Drehzahl (U/min) ', borderColor: colors.rpm }
            ], {
                scales: {
                    y: {
                        title: { display: true, text: 'Drehzahl (U/min)' },
                        beginAtZero: false
                    }
                }
            });
            // Initialize digital twin vibration chart with dashed lines
            initializeChart('dt-vibration-chart', 'Vibrationsverlauf über die Zeit (Modell)', [
                { label: 'Vibration (mm/s) ', borderColor: colors.vibration }
            ], {
                scales: {
                    y: {
                        title: { display: true, text: 'Vibration (mm/s)' },
                        beginAtZero: false
                    }
                }
            });
            // Initialize digital twin temperature chart with dashed lines
            initializeChart('dt-temp-chart', 'Temperaturverlauf über die Zeit (Modell)', [
                { label: 'Temperatur (°C) ', borderColor: colors.temperature },
                { label: 'Temperatur Mean ', borderColor: colors.mean, borderWidth: 2, tension: 0.3 },
                { label: 'Temperatur Min ', borderColor: colors.min, borderWidth: 1, borderDash: [2, 2] },
                { label: 'Temperatur Max ', borderColor: colors.max, borderWidth: 1, borderDash: [2, 2] },
                { label: 'Temperatur Median ', borderColor: colors.median, borderWidth: 1, borderDash: [5, 5] },
                { label: 'Temperatur Std ', borderColor: colors.std, borderWidth: 1, borderDash: [1, 1] }
            ], {
                scales: {
                    y: {
                        title: { display: true, text: 'Temperatur (°C)' },
                        beginAtZero: false
                    }
                }
            });
            // Initialize digital twin torque chart with dashed lines
            initializeChart('dt-torque-chart', 'Drehmomentverlauf über die Zeit (Modell)', [
                { label: 'Drehmoment (Nm) ', borderColor: colors.raw },
                { label: 'Drehmoment Mean ', borderColor: colors.mean, borderWidth: 2, tension: 0.3 },
                { label: 'Drehmoment Min ', borderColor: colors.min, borderWidth: 1, borderDash: [2, 2] },
                { label: 'Drehmoment Max ', borderColor: colors.max, borderWidth: 1, borderDash: [2, 2] },
                { label: 'Drehmoment Median ', borderColor: colors.median, borderWidth: 1, borderDash: [5, 5] },
                { label: 'Drehmoment Std ', borderColor: colors.std, borderWidth: 1, borderDash: [1, 1] }
            ], {
                scales: {
                    y: {
                        title: { display: true, text: 'Drehmoment (Nm)' },
                        beginAtZero: false
                    }
                }
            });
        });

        // WebSocket onopen event handler
        socket.onopen = function(e) {
            console.log("WebSocket connection established.");
            // On initial load, request the "last 10 minutes live" view
            socket.send(JSON.stringify({
                type: 'request_initial_data'
            }));
        };

        // WebSocket onmessage event handler
        socket.onmessage = function(e) {
            try {
                const data = JSON.parse(e.data); // Parse incoming JSON data

                // Handle different types of WebSocket messages
                if (data.error) {
                    console.error("[ERROR] Received error from WebSocket:", data.error);
                    document.getElementById('anomaly-status').textContent = `Fehler: ${data.error}`;
                    document.getElementById('anomaly-status').className = 'anomaly-status anomaly-alert';
                } else if (data.type === 'dashboard_update') {
                    // Update static UI elements with latest dashboard data
                    updateUI(data.message);
                } else if (data.type === 'plot_data_update') {
                    // Update charts with historical data
                    updateChartsWithHistoricalData(data.data, data.plot_type, data.start_time, data.end_time, data.live_mode_active);
                } else if (data.type === 'plot_data_point') {
                    // Add new live data point if liveEndTimeMode is active
                    addLatestDataPoint(data.data);
                } else {
                    console.warn("[WARN] Unhandled WebSocket message type:", data.type);
                }
            } catch (error) {
                console.error("[CRITICAL ERROR] Error parsing WebSocket message or during UI update:", error, e.data);
            }
        };

        // WebSocket onclose event handler
        socket.onclose = function(e) {
            console.error("WebSocket closed unexpectedly:", e.code, e.reason);
            document.getElementById('anomaly-status').textContent = "WebSocket-Verbindung getrennt. Versuche erneut zu verbinden...";
            document.getElementById('anomaly-status').className = 'anomaly-status anomaly-alert';
            // Attempt to reload the page after a delay to re-establish connection
            setTimeout(() => {
                window.location.reload();
            }, 3000);
        };

        // WebSocket onerror event handler
        socket.onerror = function(e) {
            console.error("WebSocket error:", e);
            document.getElementById('anomaly-status').textContent = "WebSocket-Fehler aufgetreten.";
            document.getElementById('anomaly-status').className = 'anomaly-status anomaly-alert';
        };

        // Event listener for the "Apply" button in the time range selector
        document.getElementById('apply-time-range').addEventListener('click', () => {
            const startTimeInput = document.getElementById('plot-start-time').value;
            const endTimeInput = document.getElementById('plot-end-time').value;
            const endTimeMode = document.getElementById('end-time-mode').value;

            // Validate input
            if (!startTimeInput && endTimeMode === 'fixed' && !endTimeInput) {
                alert('Bitte geben Sie mindestens eine Start- oder Endzeit ein, oder wählen Sie "Live" für die Endzeit.');
                return;
            }

            // Determine the actual end time to send to the backend
            let actualEndTime = endTimeInput;
            if (endTimeMode === 'live') {
                actualEndTime = 'live'; // Send 'live' keyword to backend
            }

            console.log(`Requesting plot data: start_time=${startTimeInput}, end_time=${actualEndTime}, end_time_mode=${endTimeMode}`);
            // Send a request to the WebSocket to fetch historical data for the specified range
            socket.send(JSON.stringify({
                type: 'request_plot_data',
                start_time: startTimeInput,
                end_time: actualEndTime // Use 'live' or the fixed date
            }));
            // The backend will set live_mode_active and send it back in plot_data_update
        });

        // Event listener for the "Show Current Run" button
        document.getElementById('reset-time-range').addEventListener('click', () => {
            // Clear the time range input fields
            document.getElementById('plot-start-time').value = '';
            document.getElementById('plot-end-time').value = '';
            document.getElementById('end-time-mode').value = 'live'; // Set to live mode
            document.getElementById('plot-end-time').disabled = true; // Disable end time input

            console.log("Requesting initial data (current run/live mode)");
            // Send a request to the WebSocket to revert to displaying initial/live data
            socket.send(JSON.stringify({
                type: 'request_initial_data'
            }));
            // The backend will set live_mode_active to true and send it back
        });

        // Event listener for the end-time-mode dropdown
        document.getElementById('end-time-mode').addEventListener('change', function() {
            const endTimeInput = document.getElementById('plot-end-time');
            if (this.value === 'live') {
                endTimeInput.disabled = true; // Disable fixed end time input
                endTimeInput.value = ''; // Clear any existing fixed end time
            } else {
                endTimeInput.disabled = false; // Enable fixed end time input
            }
        });

        // Initial setup for end-time-mode on page load
        document.addEventListener('DOMContentLoaded', () => {
            const endTimeModeSelect = document.getElementById('end-time-mode');
            const endTimeInput = document.getElementById('plot-end-time');
            // On initial load, we expect to be in live mode (as per socket.onopen request)
            liveEndTimeMode = true; // Set client-side flag to true
            endTimeModeSelect.value = 'live';
            endTimeInput.disabled = true;
            console.log("Initial DOMContentLoaded setup: liveEndTimeMode set to true, UI adjusted.");
        });
    </script>
</body>
</html>